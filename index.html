<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Network Lab - Professional Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            overflow: hidden;
            background: linear-gradient(to bottom, #0a192f, #000000);
            color: white;
        }
        
        /* Splash screen fadeout effect */
        #splash-screen {
            transition: opacity 1s ease-in-out;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            background: linear-gradient(to bottom, #0a192f, #000000); /* Dark navy to black gradient */
        }
        
        /* Animated particles background */
        #particles {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background-image: linear-gradient(rgba(0, 200, 255, 0.03) 1px, transparent 1px),
                            linear-gradient(90deg, rgba(0, 200, 255, 0.03) 1px, transparent 1px);
            background-size: 30px 30px;
            opacity: 0.5;
        }
        
        /* No particle animations for clean networking lab look */
        
        /* Main Header */
        #main-header {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(10, 25, 47, 0.7);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(0, 200, 255, 0.3);
            border-radius: 15px;
            padding: 15px 25px;
            font-size: 18px;
            font-weight: 600;
            letter-spacing: 1px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3), 0 0 10px rgba(0, 200, 255, 0.2);
            z-index: 100;
        }
        
        /* Device Palette */
        #device-palette {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 300px;
            max-height: calc(100vh - 40px);
            background: rgba(10, 25, 47, 0.7);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(0, 200, 255, 0.3);
            border-radius: 20px;
            overflow: hidden;
            z-index: 100;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3), 0 0 10px rgba(0, 200, 255, 0.2);
        }
        
        .palette-header {
            padding: 25px;
            background: rgba(10, 25, 47, 0.8);
            border-bottom: 1px solid rgba(0, 200, 255, 0.2);
            font-weight: 600;
            color: white;
            font-size: 18px;
            text-align: center;
            letter-spacing: 1px;
            text-shadow: 0 0 5px rgba(0, 200, 255, 0.5);
        }
        
        .device-grid {
            padding: 20px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            overflow-y: auto;
            max-height: calc(100vh - 200px);
        }
        
        .device-card {
            background: rgba(10, 25, 47, 0.6);
            border: 1px solid rgba(0, 200, 255, 0.15);
            border-radius: 15px;
            padding: 20px;
            cursor: grab;
            transition: all 0.3s ease;
            text-align: center;
            position: relative;
            overflow: hidden;
        }
        
        .device-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.1) 0%, transparent 70%);
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .device-card:hover {
            background: rgba(0, 200, 255, 0.1);
            border-color: rgba(0, 200, 255, 0.4);
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3), 0 0 15px rgba(0, 200, 255, 0.3);
        }
        
        .device-card:hover::before {
            opacity: 1;
        }
        
        .device-card.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }
        
        .device-icon {
            width: 60px;
            height: 60px;
            margin: 0 auto 15px;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
        }
        
        .device-name {
            font-size: 14px;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.9);
            margin-bottom: 5px;
        }
        
        .device-type {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.6);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        /* Floating Action Buttons */
        .fab-container {
            position: absolute;
            bottom: 30px;
            right: 30px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 100;
        }
        
        .fab {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: rgba(10, 25, 47, 0.7);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(0, 200, 255, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 24px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3), 0 0 10px rgba(0, 200, 255, 0.2);
        }
        
        .fab:hover {
            background: rgba(0, 200, 255, 0.2);
            transform: scale(1.1);
            box-shadow: 0 6px 30px rgba(0, 0, 0, 0.4), 0 0 15px rgba(0, 200, 255, 0.4);
        }
        
        .fab.primary {
            background: rgba(0, 200, 255, 0.5);
            border: 1px solid rgba(0, 200, 255, 0.4);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3), 0 0 15px rgba(0, 200, 255, 0.3);
        }
        
        /* Mode Selector */
        #mode-selector {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            background: rgba(10, 25, 47, 0.7);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(0, 200, 255, 0.3);
            border-radius: 30px;
            padding: 5px;
            z-index: 100;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3), 0 0 10px rgba(0, 200, 255, 0.2);
        }
        
        .mode-btn {
            padding: 10px 20px;
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            border-radius: 25px;
            transition: all 0.3s;
            font-size: 14px;
            font-weight: 500;
        }
        
        .mode-btn:hover {
            color: white;
        }
        
        .mode-btn.active {
            background: rgba(0, 200, 255, 0.2);
            color: white;
            box-shadow: 0 0 10px rgba(0, 200, 255, 0.3);
        }
        
        /* Properties Panel */
        #properties-panel {
            position: absolute;
            top: 80px;
            right: 20px;
            width: 350px;
            background: rgba(10, 25, 47, 0.7);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(0, 200, 255, 0.3);
            border-radius: 20px;
            display: none;
            z-index: 100;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3), 0 0 10px rgba(0, 200, 255, 0.2);
            overflow: hidden;
        }
        
        .panel-header {
            padding: 20px;
            background: rgba(10, 25, 47, 0.8);
            border-bottom: 1px solid rgba(0, 200, 255, 0.2);
            font-weight: 600;
            color: white;
            font-size: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            text-shadow: 0 0 5px rgba(0, 200, 255, 0.5);
        }
        
        .close-btn {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.6);
            cursor: pointer;
            font-size: 24px;
            line-height: 1;
            transition: color 0.3s;
        }
        
        .close-btn:hover {
            color: white;
        }
        
        .panel-content {
            padding: 25px;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-group label {
            display: block;
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 500;
        }
        
        .form-group input,
        .form-group select {
            width: 100%;
            background: rgba(10, 25, 47, 0.5);
            border: 1px solid rgba(0, 200, 255, 0.2);
            color: white;
            padding: 12px 15px;
            border-radius: 10px;
            font-size: 14px;
            transition: all 0.3s;
        }
        
        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: rgba(0, 200, 255, 0.5);
            background: rgba(10, 25, 47, 0.7);
            box-shadow: 0 0 10px rgba(0, 200, 255, 0.3);
        }
        
        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 25px;
        }
        
        .btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s;
        }
        
        .btn-save {
            background: rgba(0, 200, 255, 0.5);
            color: white;
            border: 1px solid rgba(0, 200, 255, 0.3);
            text-shadow: 0 0 5px rgba(0, 200, 255, 0.7);
        }
        
        .btn-save:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 200, 255, 0.4), 0 0 15px rgba(0, 200, 255, 0.3);
            background: rgba(0, 200, 255, 0.6);
        }
        
        .btn-cancel {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .btn-cancel:hover {
            background: rgba(255, 255, 255, 0.15);
        }
        
        /* Loading screen */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #2b3a42;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            transition: opacity 0.5s;
        }
        
        .loader {
            width: 60px;
            height: 60px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top-color: #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Tooltips */
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            display: none;
            white-space: nowrap;
        }
        
        /* Notification */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 15px 20px;
            display: none;
            z-index: 1000;
            animation: slideIn 0.3s ease;
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            #device-palette {
                width: 250px;
            }
            
            .device-grid {
                grid-template-columns: 1fr;
            }
            
            #properties-panel {
                width: 300px;
            }
        }
        
        /* Terminal Interface */
        .terminal-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 600px;
            height: 400px;
            background: rgba(10, 25, 47, 0.85);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(0, 200, 255, 0.3);
            border-radius: 10px;
            overflow: hidden;
            z-index: 200;
            font-family: 'Consolas', 'Monaco', monospace;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3), 0 0 15px rgba(0, 200, 255, 0.2);
        }
        
        .terminal-header {
            padding: 10px 15px;
            background: rgba(255, 255, 255, 0.1);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
        }
        
        .terminal-body {
            height: calc(100% - 40px);
            display: flex;
            flex-direction: column;
        }
        
        #terminal-output {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
            color: #0f0;
            font-size: 13px;
            line-height: 1.5;
        }
        
        .terminal-input-line {
            display: flex;
            padding: 10px 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            align-items: center;
        }
        
        .terminal-prompt {
            color: #4CAF50;
            margin-right: 10px;
            font-size: 13px;
        }
        
        .terminal-input {
            flex: 1;
            background: transparent;
            border: none;
            color: white;
            font-family: inherit;
            font-size: 13px;
            outline: none;
        }
        
        /* Network Monitor */
        .monitor-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 500px;
            height: 400px;
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            overflow: hidden;
            z-index: 200;
        }
        
        .monitor-header {
            padding: 15px 20px;
            background: rgba(255, 255, 255, 0.05);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .monitor-tabs {
            display: flex;
            background: rgba(255, 255, 255, 0.05);
            padding: 5px;
        }
        
        .monitor-tab {
            flex: 1;
            padding: 8px;
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.6);
            cursor: pointer;
            font-size: 13px;
            transition: all 0.3s;
            border-radius: 5px;
        }
        
        .monitor-tab:hover {
            color: white;
        }
        
        .monitor-tab.active {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }
        
        .monitor-content {
            height: calc(100% - 100px);
            overflow-y: auto;
        }
        
        .monitor-view {
            padding: 20px;
        }
        
        #traffic-chart {
            width: 100%;
            height: 200px;
        }
        
        /* Tutorial System */
        .tutorial-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 600px;
            max-height: 80vh;
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(30px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            overflow: hidden;
            z-index: 300;
        }
        
        .tutorial-header {
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 18px;
            font-weight: 600;
        }
        
        .tutorial-content {
            padding: 30px;
            overflow-y: auto;
            max-height: calc(80vh - 80px);
        }
        
        .tutorial-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .tutorial-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            color: white;
        }
        
        .tutorial-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }
        
        .tutorial-icon {
            display: block;
            font-size: 30px;
            margin-bottom: 10px;
        }
        
        .tutorial-title {
            display: block;
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 5px;
        }
        
        .tutorial-time {
            display: block;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
        }
        
        /* Simulation Menu */
        .simulation-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 500px;
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(30px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            overflow: hidden;
            z-index: 300;
        }
        
        .simulation-header {
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 18px;
            font-weight: 600;
        }
        
        .simulation-options {
            padding: 20px;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
        }
        
        .sim-option {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: left;
            color: white;
        }
        
        .sim-option:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-2px);
        }
        
        .sim-icon {
            display: block;
            font-size: 24px;
            margin-bottom: 10px;
        }
        
        .sim-name {
            display: block;
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 5px;
        }
        
        .sim-desc {
            display: block;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
        }
        
        /* Info Overlay */
        .info-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .info-content {
            background: rgba(10, 25, 47, 0.8);
            backdrop-filter: blur(30px);
            border: 1px solid rgba(0, 200, 255, 0.3);
            border-radius: 20px;
            padding: 40px;
            max-width: 600px;
            text-align: center;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3), 0 0 20px rgba(0, 200, 255, 0.2);
        }
        
        .info-content h2 {
            font-size: 24px;
            margin-bottom: 20px;
            color: white;
            text-shadow: 0 0 10px rgba(0, 200, 255, 0.7);
        }
        
        .info-content p {
            font-size: 16px;
            line-height: 1.6;
            color: rgba(255, 255, 255, 0.9);
            margin-bottom: 30px;
        }
        
        #info-details {
            text-align: left;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
            font-size: 14px;
            line-height: 1.8;
        }
        
        /* Enhanced tooltips for devices */
        .device-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            max-width: 250px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .device-tooltip h4 {
            margin-bottom: 5px;
            color: #4a8eb5;
        }
        
        .device-tooltip p {
            margin: 3px 0;
            font-size: 11px;
        }
    </style>
</head>
<body>
    <!-- Splash Screen -->
    <div id="splash-screen" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(to bottom, #0a192f, #000000); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 10001;">
        <!-- Glowing circular loading animation -->
        <div class="splash-loader" style="width: 120px; height: 120px; margin-bottom: 30px; border-radius: 50%; border: 3px solid rgba(0, 200, 255, 0.1); border-top-color: #00c8ff; position: relative; animation: splash-spin 1.5s linear infinite;">
            <!-- Inner glow effect -->
            <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; border-radius: 50%; box-shadow: 0 0 20px 5px rgba(0, 200, 255, 0.5); animation: pulse 2s ease-in-out infinite;"></div>
        </div>
        
        <!-- Text content -->
        <div style="text-align: center; color: white;">
            <h2 style="font-size: 28px; margin-bottom: 10px; color: #ffffff; text-shadow: 0 0 10px rgba(0, 200, 255, 0.7);">Initializing Network Laboratory</h2>
            <p style="font-size: 16px; color: rgba(255, 255, 255, 0.8); max-width: 600px; text-align: center;">Loading advanced 3D networking components and protocols...</p>
        </div>
    </div>

    <!-- Animation keyframes for splash screen -->
    <style>
        @keyframes splash-spin {
            to { transform: rotate(360deg); }
        }
        
        @keyframes pulse {
            0% { opacity: 0.3; }
            50% { opacity: 0.7; }
            100% { opacity: 0.3; }
        }
    </style>

    <!-- Removed additional loading screen, only using splash screen -->
    
    <!-- Canvas Container -->
    <div id="canvas-container">
        <div id="particles"></div>
    </div>
    
    <!-- Main Header -->
    <div id="main-header">
        üåê 3D Network Lab Pro
        <div style="float: right; font-size: 14px; margin-left: 20px;">
            <button class="header-btn" onclick="networkSim.exportNetwork()">üì• Export</button>
            <button class="header-btn" onclick="networkSim.importNetwork()">üì§ Import</button>
            <button class="header-btn" onclick="networkSim.loadNetwork()">üìÇ Load</button>
            <button class="header-btn" onclick="networkSim.saveNetwork()">üíæ Save</button>
            <button class="header-btn" onclick="networkSim.showDocumentation()">üìö Docs</button>
        </div>
    </div>
    
    <style>
        .header-btn {
            background: rgba(10, 25, 47, 0.6);
            border: 1px solid rgba(0, 200, 255, 0.3);
            color: white;
            padding: 5px 15px;
            margin-left: 10px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.3s;
        }
        
        .header-btn:hover {
            background: rgba(0, 200, 255, 0.2);
            transform: translateY(-1px);
            box-shadow: 0 0 10px rgba(0, 200, 255, 0.3);
        }
    </style>
    
    <!-- Mode Selector -->
    <div id="mode-selector">
        <button class="mode-btn active" onclick="networkSim.setMode('select')">Select</button>
        <button class="mode-btn" onclick="networkSim.setMode('connect')">Connect</button>
        <button class="mode-btn" onclick="networkSim.setMode('move')">Move</button>
        <button class="mode-btn" onclick="networkSim.setMode('delete')">Delete</button>
    </div>
    
    <!-- Device Palette -->
    <div id="device-palette">
        <div class="palette-header">Device Palette</div>
        <div class="device-grid">
            <div class="device-card" draggable="true" data-device-type="desktop">
                <div class="device-icon">üíª</div>
                <div class="device-name">Desktop PC</div>
                <div class="device-type">End Device</div>
            </div>
            <div class="device-card" draggable="true" data-device-type="laptop">
                <div class="device-icon">üíª</div>
                <div class="device-name">Laptop</div>
                <div class="device-type">End Device</div>
            </div>
            <div class="device-card" draggable="true" data-device-type="server">
                <div class="device-icon">üñ•Ô∏è</div>
                <div class="device-name">Server</div>
                <div class="device-type">End Device</div>
            </div>
            <div class="device-card" draggable="true" data-device-type="router">
                <div class="device-icon">üîÄ</div>
                <div class="device-name">Router</div>
                <div class="device-type">Network Device</div>
            </div>
            <div class="device-card" draggable="true" data-device-type="switch">
                <div class="device-icon">üîå</div>
                <div class="device-name">Switch</div>
                <div class="device-type">Network Device</div>
            </div>
            <div class="device-card" draggable="true" data-device-type="firewall">
                <div class="device-icon">üõ°Ô∏è</div>
                <div class="device-name">Firewall</div>
                <div class="device-type">Security</div>
            </div>
            <div class="device-card" draggable="true" data-device-type="wireless">
                <div class="device-icon">üì°</div>
                <div class="device-name">Access Point</div>
                <div class="device-type">Wireless</div>
            </div>
            <div class="device-card" draggable="true" data-device-type="cloud">
                <div class="device-icon">‚òÅÔ∏è</div>
                <div class="device-name">Cloud</div>
                <div class="device-type">Internet</div>
            </div>
        </div>
    </div>
    
    <!-- Floating Action Buttons -->
    <div class="fab-container">
        <div class="fab" onclick="networkSim.toggleTerminal()" title="Terminal">
            <span>üíª</span>
        </div>
        <div class="fab" onclick="networkSim.toggleMonitor()" title="Network Monitor">
            <span>üìä</span>
        </div>
        <div class="fab" onclick="networkSim.toggleTutorial()" title="Learning Mode">
            <span>üéì</span>
        </div>
        <div class="fab" onclick="networkSim.zoomIn()" title="Zoom In">
            <span>‚ûï</span>
        </div>
        <div class="fab" onclick="networkSim.zoomOut()" title="Zoom Out">
            <span>‚ûñ</span>
        </div>
        <div class="fab" onclick="networkSim.resetView()" title="Reset View">
            <span>üè†</span>
        </div>
        <div class="fab primary" onclick="networkSim.showPacketSendDialog()" title="Send Packet">
            <span>‚ñ∂Ô∏è</span>
        </div>
    </div>
    
    <!-- Properties Panel -->
    <div id="properties-panel">
        <div class="panel-header">
            <span id="panel-title">Device Properties</span>
            <button class="close-btn" onclick="networkSim.closePropertiesPanel()">√ó</button>
        </div>
        <div class="panel-content">
            <div class="form-group">
                <label>Device Name</label>
                <input type="text" id="device-name" placeholder="Enter device name">
            </div>
            <div class="form-group">
                <label>IP Address</label>
                <input type="text" id="device-ip" placeholder="192.168.1.1">
            </div>
            <div class="form-group">
                <label>Subnet Mask</label>
                <input type="text" id="device-subnet" placeholder="255.255.255.0">
            </div>
            <div class="form-group">
                <label>Status</label>
                <select id="device-status">
                    <option value="active">Active</option>
                    <option value="inactive">Inactive</option>
                </select>
            </div>
            <div class="btn-group">
                <button class="btn btn-save" onclick="networkSim.saveProperties()">Save</button>
                <button class="btn btn-cancel" onclick="networkSim.closePropertiesPanel()">Cancel</button>
            </div>
        </div>
    </div>
    
    <!-- Tooltip -->
    <div id="tooltip" class="tooltip"></div>
    
    <!-- Notification -->
    <div id="notification" class="notification"></div>
    
    <!-- Terminal Interface -->
    <div id="terminal" class="terminal-container" style="display: none;">
        <div class="terminal-header">
            <span>Network Terminal</span>
            <button class="close-btn" onclick="networkSim.toggleTerminal()">√ó</button>
        </div>
        <div class="terminal-body">
            <div id="terminal-output"></div>
            <div class="terminal-input-line">
                <span class="terminal-prompt">admin@network:~$</span>
                <input type="text" id="terminal-input" class="terminal-input" placeholder="Type 'help' for commands">
            </div>
        </div>
    </div>
    
    <!-- Network Monitor -->
    <div id="network-monitor" class="monitor-container" style="display: none;">
        <div class="monitor-header">
            <span>Network Monitor</span>
            <button class="close-btn" onclick="networkSim.toggleMonitor()">√ó</button>
        </div>
        <div class="monitor-tabs">
            <button class="monitor-tab active" onclick="networkSim.switchMonitorTab('traffic')">Traffic</button>
            <button class="monitor-tab" onclick="networkSim.switchMonitorTab('packets')">Packets</button>
            <button class="monitor-tab" onclick="networkSim.switchMonitorTab('routing')">Routing</button>
            <button class="monitor-tab" onclick="networkSim.switchMonitorTab('logs')">Logs</button>
        </div>
        <div class="monitor-content">
            <div id="traffic-view" class="monitor-view">
                <canvas id="traffic-chart"></canvas>
            </div>
            <div id="packets-view" class="monitor-view" style="display: none;">
                <div id="packet-list"></div>
            </div>
            <div id="routing-view" class="monitor-view" style="display: none;">
                <div id="routing-table"></div>
            </div>
            <div id="logs-view" class="monitor-view" style="display: none;">
                <div id="log-entries"></div>
            </div>
        </div>
    </div>
    
    <!-- Tutorial System -->
    <div id="tutorial-panel" class="tutorial-container" style="display: none;">
        <div class="tutorial-header">
            <span>Interactive Learning</span>
            <button class="close-btn" onclick="networkSim.toggleTutorial()">√ó</button>
        </div>
        <div class="tutorial-content">
            <div class="tutorial-section">
                <h3>üéØ Quick Tutorials</h3>
                <div class="tutorial-grid">
                    <button class="tutorial-btn" onclick="networkSim.startTutorial('basic-network')">
                        <span class="tutorial-icon">üåê</span>
                        <span class="tutorial-title">Basic Network Setup</span>
                        <span class="tutorial-time">5 min</span>
                    </button>
                    <button class="tutorial-btn" onclick="networkSim.startTutorial('tcp-ip')">
                        <span class="tutorial-icon">üì¶</span>
                        <span class="tutorial-title">TCP/IP Protocol</span>
                        <span class="tutorial-time">10 min</span>
                    </button>
                    <button class="tutorial-btn" onclick="networkSim.startTutorial('routing')">
                        <span class="tutorial-icon">üîÄ</span>
                        <span class="tutorial-title">Routing Basics</span>
                        <span class="tutorial-time">8 min</span>
                    </button>
                    <button class="tutorial-btn" onclick="networkSim.startTutorial('vlan')">
                        <span class="tutorial-icon">üè∑Ô∏è</span>
                        <span class="tutorial-title">VLAN Configuration</span>
                        <span class="tutorial-time">7 min</span>
                    </button>
                    <button class="tutorial-btn" onclick="networkSim.startTutorial('security')">
                        <span class="tutorial-icon">üîí</span>
                        <span class="tutorial-title">Network Security</span>
                        <span class="tutorial-time">12 min</span>
                    </button>
                    <button class="tutorial-btn" onclick="networkSim.startTutorial('troubleshoot')">
                        <span class="tutorial-icon">üîß</span>
                        <span class="tutorial-title">Troubleshooting</span>
                        <span class="tutorial-time">15 min</span>
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Simulation Menu -->
    <div id="simulation-menu" class="simulation-menu" style="display: none;">
        <div class="simulation-header">
            <span>Network Simulations</span>
            <button class="close-btn" onclick="networkSim.hideSimulationMenu()">√ó</button>
        </div>
        <div class="simulation-options">
            <button class="sim-option" onclick="networkSim.runSimulation('ping')">
                <span class="sim-icon">üì°</span>
                <span class="sim-name">Ping Test</span>
                <span class="sim-desc">ICMP echo request/reply</span>
            </button>
            <button class="sim-option" onclick="networkSim.runSimulation('traceroute')">
                <span class="sim-icon">üõ§Ô∏è</span>
                <span class="sim-name">Traceroute</span>
                <span class="sim-desc">Trace packet path</span>
            </button>
            <button class="sim-option" onclick="networkSim.runSimulation('dhcp')">
                <span class="sim-icon">üìã</span>
                <span class="sim-name">DHCP Process</span>
                <span class="sim-desc">Dynamic IP assignment</span>
            </button>
            <button class="sim-option" onclick="networkSim.runSimulation('dns')">
                <span class="sim-icon">üåç</span>
                <span class="sim-name">DNS Resolution</span>
                <span class="sim-desc">Domain name lookup</span>
            </button>
            <button class="sim-option" onclick="networkSim.runSimulation('tcp-handshake')">
                <span class="sim-icon">ü§ù</span>
                <span class="sim-name">TCP Handshake</span>
                <span class="sim-desc">3-way connection setup</span>
            </button>
            <button class="sim-option" onclick="networkSim.runSimulation('arp')">
                <span class="sim-icon">üìç</span>
                <span class="sim-name">ARP Request</span>
                <span class="sim-desc">MAC address resolution</span>
            </button>
        </div>
    </div>
    
    <!-- Info Overlay -->
    <div id="info-overlay" class="info-overlay" style="display: none;">
        <div class="info-content">
            <h2 id="info-title"></h2>
            <p id="info-description"></p>
            <div id="info-details"></div>
            <button class="btn btn-primary" onclick="networkSim.closeInfoOverlay()">Got it!</button>
        </div>
    </div>
    
    <!-- Subnet Calculator -->
    <div id="subnet-calculator" class="modal" style="display: none;">
        <div class="modal-header">
            <span>Subnet Calculator</span>
            <button class="close-btn" onclick="networkSim.closeSubnetCalculator()">√ó</button>
        </div>
        <div class="modal-content" style="padding: 20px;">
            <div class="form-group">
                <label>IP Address</label>
                <input type="text" id="subnet-ip" placeholder="192.168.1.0" value="192.168.1.0">
            </div>
            <div class="form-group">
                <label>Subnet Mask / CIDR</label>
                <input type="text" id="subnet-mask" placeholder="255.255.255.0 or /24" value="/24">
            </div>
            <button class="btn btn-primary" onclick="networkSim.calculateSubnet()">Calculate</button>
            <div id="subnet-results" style="margin-top: 20px; font-size: 14px;"></div>
        </div>
    </div>
    
    <!-- VLAN Configuration -->
    <div id="vlan-config" class="modal" style="display: none;">
        <div class="modal-header">
            <span>VLAN Configuration</span>
            <button class="close-btn" onclick="networkSim.closeVLANConfig()">√ó</button>
        </div>
        <div class="modal-content" style="padding: 20px;">
            <div class="form-group">
                <label>VLAN ID</label>
                <input type="number" id="vlan-id" min="1" max="4094" value="1">
            </div>
            <div class="form-group">
                <label>VLAN Name</label>
                <input type="text" id="vlan-name" placeholder="Sales_VLAN">
            </div>
            <div class="form-group">
                <label>Color</label>
                <select id="vlan-color">
                    <option value="#4CAF50">Green</option>
                    <option value="#2196F3">Blue</option>
                    <option value="#FF9800">Orange</option>
                    <option value="#E91E63">Pink</option>
                    <option value="#9C27B0">Purple</option>
                </select>
            </div>
            <button class="btn btn-primary" onclick="networkSim.applyVLAN()">Apply VLAN</button>
            <div id="vlan-devices" style="margin-top: 20px;"></div>
        </div>
    </div>
    
    <!-- Network Documentation -->
    <div id="network-docs" class="modal" style="display: none;">
        <div class="modal-header">
            <span>Network Documentation</span>
            <button class="close-btn" onclick="networkSim.closeDocumentation()">√ó</button>
        </div>
        <div class="modal-content" style="padding: 20px; max-height: 70vh; overflow-y: auto;">
            <div id="docs-content"></div>
            <div class="btn-group" style="margin-top: 20px;">
                <button class="btn btn-primary" onclick="networkSim.generatePDF()">Export PDF</button>
                <button class="btn btn-secondary" onclick="networkSim.copyDocumentation()">Copy Text</button>
            </div>
        </div>
    </div>
    
    <style>
        .modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(30px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            z-index: 500;
            min-width: 400px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        .modal-header {
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px 20px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 18px;
            font-weight: 600;
        }
        
        .modal-content {
            padding: 30px;
            color: white;
        }
        
        #subnet-results {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            line-height: 1.8;
        }
        
        .result-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
        }
        
        .result-label {
            color: rgba(255, 255, 255, 0.7);
        }
        
        .result-value {
            color: #4a8eb5;
            font-family: monospace;
        }
    </style>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // No particles for clean networking lab look
        
        // Network Simulator Class
        class NetworkSimulator {
            // Network topology constants
            static DEVICE_TYPES = {
                END_DEVICE: ['desktop', 'laptop', 'server'],
                LAYER2_DEVICE: ['switch', 'hub'],
                LAYER3_DEVICE: ['router', 'firewall'],
                WIRELESS: ['wireless'],
                WAN: ['cloud']
            };
            
            // Routing table constants
            static ROUTE_TYPES = {
                DIRECT: 'direct',    // Directly connected network
                STATIC: 'static',    // Manually configured route
                DYNAMIC: 'dynamic'   // Learned through routing protocol
            };
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null;
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                
                this.devices = [];
                this.connections = [];
                this.selectedDevice = null;
                this.draggedDevice = null;
                this.connectingDevice = null;
                
                this.mode = 'select';
                
                // Professional features
                this.terminal = new NetworkTerminal(this);
                this.monitor = new NetworkMonitor(this);
                this.packetSimulator = new PacketSimulator(this);
                this.tutorialSystem = new TutorialSystem(this);
                
                this.init();
                this.animate();
                
                // Hide splash screen and show welcome message
                setTimeout(() => {
                    const splashScreen = document.getElementById('splash-screen');
                    splashScreen.style.opacity = '0';
                    splashScreen.style.transition = 'opacity 1s';
                    
                    setTimeout(() => {
                        splashScreen.style.display = 'none';
                        
                        // Show welcome message
                        this.showInfoOverlay(
                            'Welcome to Network Simulator Pro! üåê',
                            'Learn computer networking through interactive 3D visualization.',
                            `<strong>Getting Started:</strong><br>
                            ‚Ä¢ <strong>Drag devices</strong> from the left palette to build your network<br>
                            ‚Ä¢ <strong>Connect devices</strong> using Connect Mode (button 2)<br>
                            ‚Ä¢ <strong>Configure devices</strong> by clicking them in Select Mode<br>
                            ‚Ä¢ <strong>Run simulations</strong> to see protocols in action<br>
                            ‚Ä¢ <strong>Use the terminal</strong> (Ctrl+T) for advanced commands<br><br>
                            <strong>Tips:</strong><br>
                            ‚Ä¢ Ctrl+Click on devices to see detailed information<br>
                            ‚Ä¢ Press H for keyboard shortcuts<br>
                            ‚Ä¢ Try the tutorials for guided learning!`
                        );
                    }, 1000);
                }, 3000);
            }
            
            init() {
                // Scene setup
                this.scene = new THREE.Scene();
                
                // Camera setup
                this.camera = new THREE.PerspectiveCamera(
                    60,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                this.camera.position.set(30, 40, 50);
                this.camera.lookAt(0, 0, 0);
                
                // Renderer setup
                this.renderer = new THREE.WebGLRenderer({ 
                    antialias: true,
                    alpha: true 
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);
                
                // Controls
                this.controls = new CameraControls(this.camera, this.renderer.domElement);
                
                // Lighting with blue-cyan accent
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(20, 50, 20);
                directionalLight.castShadow = true;
                directionalLight.shadow.camera.left = -50;
                directionalLight.shadow.camera.right = 50;
                directionalLight.shadow.camera.top = 50;
                directionalLight.shadow.camera.bottom = -50;
                this.scene.add(directionalLight);
                
                // Add cyan rim lighting for futuristic glow
                const rimLight = new THREE.DirectionalLight(0x00c8ff, 0.4);
                rimLight.position.set(-20, 10, -20);
                this.scene.add(rimLight);
                
                // Add subtle cyan point light for glow effect
                const glowLight = new THREE.PointLight(0x00c8ff, 0.3, 100);
                glowLight.position.set(0, 10, 0);
                this.scene.add(glowLight);
                
                // Create curved grid floor with glowing elements
                this.createCurvedGrid();
                
                // Setup event listeners
                this.setupEventListeners();
                
                // Initialize terminal commands
                this.terminal.sim = this;
                this.terminal.setupTerminal();
            }
            
            createCurvedGrid() {
                // Create a curved surface using a parametric geometry
                const gridSize = 80;
                const segments = 40;
                
                // Grid geometry
                const geometry = new THREE.PlaneGeometry(gridSize, gridSize, segments, segments);
                
                // Apply curve to vertices
                const positionAttribute = geometry.attributes.position;
                for (let i = 0; i < positionAttribute.count; i++) {
                    const x = positionAttribute.getX(i);
                    const z = positionAttribute.getZ(i);
                    const distance = Math.sqrt(x * x + z * z);
                    const y = -Math.pow(distance / 40, 2) * 5;
                    positionAttribute.setY(i, y);
                }
                
                geometry.computeVertexNormals();
                
                // Grid material with glowing cyan color
                const gridMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00c8ff,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.25
                });
                
                const gridMesh = new THREE.Mesh(geometry, gridMaterial);
                gridMesh.rotation.x = -Math.PI / 2;
                this.scene.add(gridMesh);
                
                // Add glow plane beneath with cyan glow
                const glowGeometry = new THREE.PlaneGeometry(gridSize * 1.2, gridSize * 1.2);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00c8ff,
                    transparent: true,
                    opacity: 0.08,
                    side: THREE.DoubleSide
                });
                const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
                glowMesh.rotation.x = -Math.PI / 2;
                glowMesh.position.y = -10;
                this.scene.add(glowMesh);
            }
            
            // Device creation methods
            createDesktopGeometry() {
                const group = new THREE.Group();
                
                // Monitor
                const monitorGeometry = new THREE.BoxGeometry(3, 2, 0.2);
                const monitorMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x475a6c,
                    emissive: 0x2c3e50,
                    emissiveIntensity: 0.1
                });
                const monitor = new THREE.Mesh(monitorGeometry, monitorMaterial);
                monitor.position.y = 2;
                monitor.castShadow = true;
                monitor.receiveShadow = true;
                group.add(monitor);
                
                // Screen
                const screenGeometry = new THREE.BoxGeometry(2.6, 1.6, 0.1);
                const screenMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x000000,
                    emissive: 0x4a8eb5,
                    emissiveIntensity: 0.2
                });
                const screen = new THREE.Mesh(screenGeometry, screenMaterial);
                screen.position.set(0, 2, 0.15);
                group.add(screen);
                
                // Base
                const baseGeometry = new THREE.BoxGeometry(3.5, 0.5, 2);
                const baseMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x2d3748
                });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.y = 0.25;
                base.castShadow = true;
                base.receiveShadow = true;
                group.add(base);
                
                return group;
            }
            
            createLaptopGeometry() {
                const group = new THREE.Group();
                
                // Base
                const baseGeometry = new THREE.BoxGeometry(3, 0.2, 2);
                const baseMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x4a5568,
                    metalness: 0.5,
                    roughness: 0.5
                });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.castShadow = true;
                base.receiveShadow = true;
                group.add(base);
                
                // Screen
                const screenGeometry = new THREE.BoxGeometry(2.8, 1.8, 0.1);
                const screenMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x1a202c,
                    emissive: 0x3182ce,
                    emissiveIntensity: 0.4
                });
                const screen = new THREE.Mesh(screenGeometry, screenMaterial);
                screen.position.set(0, 1, -0.9);
                screen.rotation.x = -0.3;
                screen.castShadow = true;
                group.add(screen);
                
                return group;
            }
            
            createServerGeometry() {
                const group = new THREE.Group();
                
                // Server chassis
                const chassisGeometry = new THREE.BoxGeometry(3, 4, 3);
                const chassisMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x1a202c,
                    metalness: 0.7,
                    roughness: 0.3
                });
                const chassis = new THREE.Mesh(chassisGeometry, chassisMaterial);
                chassis.position.y = 2;
                chassis.castShadow = true;
                chassis.receiveShadow = true;
                group.add(chassis);
                
                // Server slots
                for (let i = 0; i < 4; i++) {
                    const slotGeometry = new THREE.BoxGeometry(2.6, 0.6, 0.1);
                    const slotMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0x2d3748,
                        emissive: 0x48bb78,
                        emissiveIntensity: 0.2
                    });
                    const slot = new THREE.Mesh(slotGeometry, slotMaterial);
                    slot.position.set(0, 0.5 + i * 0.9, 1.5);
                    group.add(slot);
                }
                
                return group;
            }
            
            createRouterGeometry() {
                const group = new THREE.Group();
                
                // Main body
                const bodyGeometry = new THREE.CylinderGeometry(2, 2, 1, 8);
                const bodyMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x4a8eb5, // Professional blue color
                    metalness: 0.5,
                    roughness: 0.5
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.5;
                body.castShadow = true;
                body.receiveShadow = true;
                group.add(body);
                
                // Antennas
                for (let i = 0; i < 3; i++) {
                    const antennaGeometry = new THREE.CylinderGeometry(0.1, 0.1, 3);
                    const antennaMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0x2d3748,
                        metalness: 0.8,
                        roughness: 0.2
                    });
                    const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
                    antenna.position.set(Math.cos(i * 2.1) * 1.5, 2, Math.sin(i * 2.1) * 1.5);
                    antenna.castShadow = true;
                    group.add(antenna);
                }
                
                // LED indicators
                const ledGeometry = new THREE.SphereGeometry(0.1);
                for (let i = 0; i < 5; i++) {
                    const ledMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0x48bb78,
                        emissive: 0x48bb78,
                        emissiveIntensity: 0.8
                    });
                    const led = new THREE.Mesh(ledGeometry, ledMaterial);
                    led.position.set(-0.8 + i * 0.4, 0.8, 2);
                    group.add(led);
                }
                
                return group;
            }
            
            // Initialize router with routing table
            initializeRouterData(router) {
                if (!router.userData.routingTable) {
                    router.userData.routingTable = [];
                    router.userData.interfaces = [];
                    
                    // Assign interface numbers to connections
                    const connectedDevices = this.getConnectedDevices(router);
                    connectedDevices.forEach((device, index) => {
                        // Create interface entry with unique ID
                        router.userData.interfaces.push({
                            id: `eth${index}`,
                            connectedTo: device.userData.name,
                            status: 'up'
                        });
                        
                        // For directly connected networks, add to routing table
                        if (device.userData.ip) {
                            const networkPrefix = this.getSubnetPrefix(device.userData.ip, device.userData.subnet);
                            if (networkPrefix) {
                                this.addRouteToRouter(router, {
                                    destination: networkPrefix,
                                    netmask: device.userData.subnet,
                                    nextHop: null, // Direct connection
                                    interface: `eth${index}`,
                                    metric: 0,
                                    type: NetworkSimulator.ROUTE_TYPES.DIRECT
                                });
                            }
                        }
                    });
                }
                return router;
            }
            
            // Add a route to a router's routing table
            addRouteToRouter(router, route) {
                if (!router.userData.routingTable) {
                    router.userData.routingTable = [];
                }
                
                // Check if route already exists
                const existingRouteIndex = router.userData.routingTable.findIndex(r => 
                    r.destination === route.destination && r.netmask === route.netmask);
                
                if (existingRouteIndex >= 0) {
                    // Update existing route if new route has better metric
                    if (route.metric < router.userData.routingTable[existingRouteIndex].metric) {
                        router.userData.routingTable[existingRouteIndex] = route;
                    }
                } else {
                    // Add new route
                    router.userData.routingTable.push(route);
                }
            }
            
            // Build routing tables for all routers in the network
            buildAllRoutingTables() {
                const routers = this.devices.filter(d => 
                    NetworkSimulator.DEVICE_TYPES.LAYER3_DEVICE.includes(d.userData.type));
                
                // First initialize direct connections for all routers
                routers.forEach(router => this.initializeRouterData(router));
                
                // Then build routes between routers (simple distance-vector approach)
                for (let i = 0; i < 3; i++) { // Run multiple iterations for convergence
                    routers.forEach(router => {
                        // Get all routes from this router
                        const routerRoutes = router.userData.routingTable || [];
                        
                        // For each connected router, share routes
                        const connectedRouters = this.getConnectedDevices(router).filter(d => 
                            NetworkSimulator.DEVICE_TYPES.LAYER3_DEVICE.includes(d.userData.type));
                        
                        connectedRouters.forEach(neighbor => {
                            // Find the interface to this neighbor
                            const interfaceToNeighbor = router.userData.interfaces.find(intf => 
                                intf.connectedTo === neighbor.userData.name);
                            
                            if (!interfaceToNeighbor) return;
                            
                            // Share all routes with the neighbor
                            routerRoutes.forEach(route => {
                                // Skip direct connections to other interfaces
                                if (route.type === NetworkSimulator.ROUTE_TYPES.DIRECT && 
                                    route.interface !== interfaceToNeighbor.id) {
                                    
                                    // Add route to neighbor with increased metric
                                    this.addRouteToRouter(neighbor, {
                                        destination: route.destination,
                                        netmask: route.netmask,
                                        nextHop: router.userData.name,
                                        interface: this.getInterfaceToDevice(neighbor, router)?.id,
                                        metric: route.metric + 1,
                                        type: NetworkSimulator.ROUTE_TYPES.DYNAMIC
                                    });
                                }
                            });
                        });
                    });
                }
                
                // Log routing tables to console for debugging
                console.log('All routing tables built:', routers.map(r => ({
                    router: r.userData.name,
                    table: r.userData.routingTable
                })));
            }
            
            // Get the interface that connects to a specific device
            getInterfaceToDevice(router, targetDevice) {
                if (!router.userData.interfaces) return null;
                
                return router.userData.interfaces.find(intf => 
                    intf.connectedTo === targetDevice.userData.name);
            }
            
            // Look up a route in a router's routing table
            lookupRouteForDestination(router, destIp) {
                if (!router.userData.routingTable) return null;
                
                // Find the most specific matching route (longest prefix match)
                let bestRoute = null;
                let bestPrefixLength = -1;
                
                router.userData.routingTable.forEach(route => {
                    // Check if the destination IP matches this route
                    if (this.isIpInNetwork(destIp, route.destination, route.netmask)) {
                        // Calculate prefix length from netmask
                        const prefixLength = this.getNetmaskPrefixLength(route.netmask);
                        
                        // If this is more specific than our current best match, use it
                        if (prefixLength > bestPrefixLength) {
                            bestRoute = route;
                            bestPrefixLength = prefixLength;
                        }
                    }
                });
                
                return bestRoute;
            }
            
            // Check if an IP is within a network
            isIpInNetwork(ip, networkPrefix, netmask) {
                const ipInNetwork = this.getSubnetPrefix(ip, netmask);
                return ipInNetwork === networkPrefix;
            }
            
            // Get prefix length from netmask (e.g., 255.255.255.0 -> 24)
            getNetmaskPrefixLength(netmask) {
                const parts = netmask.split('.').map(Number);
                let prefixLength = 0;
                
                for (let i = 0; i < 4; i++) {
                    // Count bits set to 1 in each octet
                    let octet = parts[i];
                    while (octet) {
                        prefixLength += octet & 1;
                        octet >>= 1;
                    }
                }
                
                return prefixLength;
            }
            
            createSwitchGeometry() {
                const group = new THREE.Group();
                
                // Main body
                const bodyGeometry = new THREE.BoxGeometry(5, 0.8, 2.5);
                const bodyMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x3a5a78, // Slightly different blue for switches
                    metalness: 0.5,
                    roughness: 0.5
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.4;
                body.castShadow = true;
                body.receiveShadow = true;
                group.add(body);
                
                // Ethernet ports
                for (let i = 0; i < 8; i++) {
                    const portGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.1);
                    const portMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0xf6ad55,
                        emissive: 0xf6ad55,
                        emissiveIntensity: 0.5
                    });
                    const port = new THREE.Mesh(portGeometry, portMaterial);
                    port.position.set(-2 + i * 0.6, 0.6, 1.25);
                    group.add(port);
                }
                
                return group;
            }
            
            createFirewallGeometry() {
                const group = new THREE.Group();
                
                // Main body
                const bodyGeometry = new THREE.BoxGeometry(4, 2, 3);
                const bodyMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xaa5555, // Muted red for firewall
                    metalness: 0.4,
                    roughness: 0.6
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 1;
                body.castShadow = true;
                body.receiveShadow = true;
                group.add(body);
                
                // Shield emblem
                const shieldGeometry = new THREE.ConeGeometry(0.8, 1.2, 3);
                const shieldMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xffffff,
                    emissive: 0xffffff,
                    emissiveIntensity: 0.2
                });
                const shield = new THREE.Mesh(shieldGeometry, shieldMaterial);
                shield.position.set(0, 1, 1.5);
                shield.rotation.z = Math.PI;
                group.add(shield);
                
                return group;
            }
            
            createWirelessGeometry() {
                const group = new THREE.Group();
                
                // Base
                const baseGeometry = new THREE.CylinderGeometry(1.5, 1.5, 0.5, 16);
                const baseMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x63a8c9, // Professional blue for wireless
                    metalness: 0.5,
                    roughness: 0.5
                });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.y = 0.25;
                base.castShadow = true;
                base.receiveShadow = true;
                group.add(base);
                
                // Antennas
                for (let i = 0; i < 2; i++) {
                    const antennaGeometry = new THREE.CylinderGeometry(0.08, 0.08, 3);
                    const antennaMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0x2d3748,
                        metalness: 0.8,
                        roughness: 0.2
                    });
                    const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
                    antenna.position.set(i === 0 ? -0.7 : 0.7, 1.75, 0);
                    antenna.castShadow = true;
                    group.add(antenna);
                }
                
                // Signal rings
                for (let i = 0; i < 3; i++) {
                    const ringGeometry = new THREE.TorusGeometry(1 + i * 0.5, 0.05, 8, 32);
                    const ringMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0x4299e1,
                        transparent: true,
                        opacity: 0.3 - i * 0.1
                    });
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.position.y = 2;
                    ring.rotation.x = -Math.PI / 2;
                    group.add(ring);
                }
                
                return group;
            }
            
            createHubGeometry() {
                const group = new THREE.Group();
                
                // Main body - octagonal shape
                const bodyGeometry = new THREE.CylinderGeometry(2, 2, 0.8, 8);
                const bodyMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x795548,
                    metalness: 0.3,
                    roughness: 0.7
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.4;
                body.castShadow = true;
                body.receiveShadow = true;
                group.add(body);
                
                // Ports around the edge
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const portGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
                    const portMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0x444444,
                        emissive: 0xffaa00,
                        emissiveIntensity: Math.random() > 0.5 ? 0.3 : 0
                    });
                    const port = new THREE.Mesh(portGeometry, portMaterial);
                    port.position.x = Math.cos(angle) * 1.5;
                    port.position.z = Math.sin(angle) * 1.5;
                    port.position.y = 0.4;
                    group.add(port);
                }
                
                // Center indicator
                const centerGeometry = new THREE.SphereGeometry(0.2);
                const centerMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x4CAF50,
                    emissive: 0x4CAF50,
                    emissiveIntensity: 0.5
                });
                const center = new THREE.Mesh(centerGeometry, centerMaterial);
                center.position.y = 0.8;
                group.add(center);
                
                return group;
            }
            
            createCloudGeometry() {
                const group = new THREE.Group();
                
                // Cloud shape using spheres
                const cloudMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x7a8c99, // Muted gray-blue for cloud
                    transparent: true,
                    opacity: 0.85,
                    emissive: 0x7a8c99,
                    emissiveIntensity: 0.1
                });
                
                const positions = [
                    { x: 0, y: 0, z: 0, r: 1.5 },
                    { x: -1, y: 0, z: 0, r: 1.2 },
                    { x: 1, y: 0, z: 0, r: 1.2 },
                    { x: 0, y: 0.5, z: 0, r: 1 },
                    { x: -0.5, y: -0.3, z: 0.5, r: 0.8 },
                    { x: 0.5, y: -0.3, z: -0.5, r: 0.8 }
                ];
                
                positions.forEach(pos => {
                    const sphereGeometry = new THREE.SphereGeometry(pos.r, 16, 16);
                    const sphere = new THREE.Mesh(sphereGeometry, cloudMaterial);
                    sphere.position.set(pos.x, pos.y + 2, pos.z);
                    sphere.castShadow = true;
                    sphere.receiveShadow = true;
                    group.add(sphere);
                });
                
                return group;
            }
            
            // Add device to scene
            addDeviceAtPosition(type, x, z) {
                let deviceMesh;
                
                switch(type) {
                    case 'desktop':
                        deviceMesh = this.createDesktopGeometry();
                        break;
                    case 'laptop':
                        deviceMesh = this.createLaptopGeometry();
                        break;
                    case 'server':
                        deviceMesh = this.createServerGeometry();
                        break;
                    case 'router':
                        deviceMesh = this.createRouterGeometry();
                        break;
                    case 'switch':
                        deviceMesh = this.createSwitchGeometry();
                        break;
                    case 'firewall':
                        deviceMesh = this.createFirewallGeometry();
                        break;
                    case 'wireless':
                        deviceMesh = this.createWirelessGeometry();
                        break;
                    case 'hub':
                        deviceMesh = this.createHubGeometry();
                        break;
                    case 'cloud':
                        deviceMesh = this.createCloudGeometry();
                        break;
                }
                
                // Position on curved surface
                const distance = Math.sqrt(x * x + z * z);
                const y = -Math.pow(distance / 40, 2) * 5;
                deviceMesh.position.set(x, y, z);
                
                deviceMesh.userData = {
                    type: type,
                    name: `${type}_${this.devices.length + 1}`,
                    ip: `192.168.1.${this.devices.length + 1}`,
                    subnet: '255.255.255.0',
                    status: 'active',
                    connections: [],
                    mac: this.generateMACAddress()
                };
                
                this.scene.add(deviceMesh);
                this.devices.push(deviceMesh);
                
                // Add label
                this.addDeviceLabel(deviceMesh);
                
                // Animate appearance
                this.animateDeviceAppearance(deviceMesh);
                
                this.showNotification(`${type} added to network`);
            }
            
            generateMACAddress() {
                const hex = '0123456789ABCDEF';
                let mac = '';
                for (let i = 0; i < 6; i++) {
                    if (i > 0) mac += ':';
                    mac += hex[Math.floor(Math.random() * 16)];
                    mac += hex[Math.floor(Math.random() * 16)];
                }
                return mac;
            }
            
            addDeviceLabel(device) {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                
                context.fillStyle = 'rgba(255, 255, 255, 0.9)';
                context.font = '20px Arial';
                context.textAlign = 'center';
                context.fillText(device.userData.name, 128, 25);
                
                context.font = '14px Arial';
                context.fillStyle = 'rgba(255, 255, 255, 0.7)';
                context.fillText(device.userData.ip, 128, 45);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ 
                    map: texture,
                    transparent: true
                });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(4, 1, 1);
                sprite.position.y = 4;
                
                device.add(sprite);
                device.userData.label = sprite;
            }
            
            animateDeviceAppearance(device) {
                device.scale.set(0.1, 0.1, 0.1);
                const targetScale = 1;
                const animationDuration = 500;
                const startTime = Date.now();
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / animationDuration, 1);
                    
                    const easeOutQuart = 1 - Math.pow(1 - progress, 4);
                    const scale = 0.1 + (targetScale - 0.1) * easeOutQuart;
                    device.scale.set(scale, scale, scale);
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    }
                };
                animate();
            }
            
            // Connection management
            createConnection(device1, device2) {
                const exists = this.connections.some(conn => 
                    (conn.device1 === device1 && conn.device2 === device2) ||
                    (conn.device1 === device2 && conn.device2 === device1)
                );
                
                if (exists) {
                    this.showNotification('Connection already exists', 'warning');
                    return;
                }
                
                // Create glowing connection line
                const points = [];
                const segments = 50;
                
                for (let i = 0; i <= segments; i++) {
                    const t = i / segments;
                    const point = new THREE.Vector3().lerpVectors(
                        device1.position,
                        device2.position,
                        t
                    );
                    
                    // Add subtle curve for cleaner look
                    const midPoint = 0.5;
                    const curveHeight = 1.5;
                    const curveFactor = 4 * (t - midPoint) * (t - midPoint);
                    point.y += curveHeight * (1 - curveFactor);
                    
                    points.push(point);
                }
                
                const curve = new THREE.CatmullRomCurve3(points);
                const tubeGeometry = new THREE.TubeGeometry(curve, 50, 0.1, 8, false);
                const tubeMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x4a8eb5,
                    emissive: 0x4a8eb5,
                    emissiveIntensity: 0.3,
                    transparent: true,
                    opacity: 0.8
                });
                const tube = new THREE.Mesh(tubeGeometry, tubeMaterial);
                
                this.scene.add(tube);
                
                const connection = {
                    device1: device1,
                    device2: device2,
                    line: tube
                };
                
                this.connections.push(connection);
                device1.userData.connections.push(device2);
                device2.userData.connections.push(device1);
                
                this.showNotification('Devices connected');
            }
            
            updateConnections() {
                this.connections.forEach(conn => {
                    const points = [];
                    const segments = 50;
                    
                    for (let i = 0; i <= segments; i++) {
                        const t = i / segments;
                        const point = new THREE.Vector3().lerpVectors(
                            conn.device1.position,
                            conn.device2.position,
                            t
                        );
                        
                        const midPoint = 0.5;
                        const curveHeight = 3;
                        const curveFactor = 4 * (t - midPoint) * (t - midPoint);
                        point.y += curveHeight * (1 - curveFactor);
                        
                        points.push(point);
                    }
                    
                    const curve = new THREE.CatmullRomCurve3(points);
                    const newGeometry = new THREE.TubeGeometry(curve, 50, 0.1, 8, false);
                    
                    conn.line.geometry.dispose();
                    conn.line.geometry = newGeometry;
                });
            }
            
            // Event handling
            setupEventListeners() {
                // Mouse events
                this.renderer.domElement.addEventListener('mousedown', (e) => this.onMouseDown(e));
                this.renderer.domElement.addEventListener('mousemove', (e) => this.onMouseMove(e));
                this.renderer.domElement.addEventListener('mouseup', (e) => this.onMouseUp(e));
                this.renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());
                
                // Window resize
                window.addEventListener('resize', () => this.onWindowResize());
                
                // Keyboard
                window.addEventListener('keydown', (e) => this.onKeyDown(e));
                
                // Drag and drop
                this.setupDragAndDrop();
            }
            
            setupDragAndDrop() {
                const deviceCards = document.querySelectorAll('.device-card');
                const canvasContainer = document.getElementById('canvas-container');
                
                deviceCards.forEach(card => {
                    card.addEventListener('dragstart', (e) => {
                        e.dataTransfer.effectAllowed = 'copy';
                        e.dataTransfer.setData('deviceType', card.dataset.deviceType);
                        card.classList.add('dragging');
                    });
                    
                    card.addEventListener('dragend', (e) => {
                        card.classList.remove('dragging');
                    });
                });
                
                canvasContainer.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'copy';
                });
                
                canvasContainer.addEventListener('drop', (e) => {
                    e.preventDefault();
                    
                    const deviceType = e.dataTransfer.getData('deviceType');
                    if (!deviceType) return;
                    
                    const rect = this.renderer.domElement.getBoundingClientRect();
                    const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                    const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                    
                    this.raycaster.setFromCamera(new THREE.Vector2(x, y), this.camera);
                    const planeNormal = new THREE.Vector3(0, 1, 0);
                    const plane = new THREE.Plane(planeNormal, 0);
                    const intersection = new THREE.Vector3();
                    
                    if (this.raycaster.ray.intersectPlane(plane, intersection)) {
                        this.addDeviceAtPosition(deviceType, intersection.x, intersection.z);
                    }
                });
            }
            
            onMouseDown(event) {
                this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObjects(this.devices, true);
                
                if (intersects.length > 0) {
                    const device = this.findParentDevice(intersects[0].object);
                    
                    switch(this.mode) {
                        case 'select':
                            this.selectDevice(device);
                            // Show device info overlay when clicking in select mode
                            if (event.ctrlKey) {
                                const info = this.getDeviceInfo(device);
                                this.showInfoOverlay(
                                    `${device.userData.name} - ${info.name}`,
                                    info.description,
                                    info.details
                                );
                            }
                            break;
                        case 'move':
                            this.draggedDevice = device;
                            this.controls.enabled = false;
                            break;
                        case 'connect':
                            this.handleConnect(device);
                            break;
                        case 'delete':
                            if (confirm(`Delete ${device.userData.name}?`)) {
                                this.deleteDevice(device);
                            }
                            break;
                    }
                }
            }
            
            onMouseMove(event) {
                this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                if (this.draggedDevice && this.mode === 'move') {
                    this.raycaster.setFromCamera(this.mouse, this.camera);
                    const planeNormal = new THREE.Vector3(0, 1, 0);
                    const plane = new THREE.Plane(planeNormal, 0);
                    const intersection = new THREE.Vector3();
                    this.raycaster.ray.intersectPlane(plane, intersection);
                    
                    // Use flat positioning for clean lab look
                    this.draggedDevice.position.x = intersection.x;
                    this.draggedDevice.position.y = 0; // Keep flat on grid
                    this.draggedDevice.position.z = intersection.z;
                    
                    this.updateConnections();
                } else {
                    // Handle hover with educational tooltips
                    this.handleHover(event);
                }
            }
            
            handleHover(event) {
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObjects(this.devices, true);
                
                const tooltip = document.getElementById('tooltip');
                
                if (intersects.length > 0) {
                    const device = this.findParentDevice(intersects[0].object);
                    const deviceInfo = this.getDeviceInfo(device);
                    
                    // Show educational tooltip
                    tooltip.innerHTML = `
                        <strong>${device.userData.name}</strong><br>
                        <small>${deviceInfo.description}</small><br>
                        <small style="color: #4CAF50;">IP: ${device.userData.ip}</small>
                    `;
                    tooltip.style.display = 'block';
                    tooltip.style.left = event.clientX + 10 + 'px';
                    tooltip.style.top = event.clientY + 10 + 'px';
                    
                    document.body.style.cursor = 'pointer';
                } else {
                    tooltip.style.display = 'none';
                    document.body.style.cursor = 'default';
                }
            }
            
            onMouseUp(event) {
                this.draggedDevice = null;
                this.controls.enabled = true;
            }
            
            onKeyDown(event) {
                switch(event.key) {
                    case 'Delete':
                        if (this.selectedDevice) {
                            this.deleteDevice(this.selectedDevice);
                        }
                        break;
                    case 'Escape':
                        this.deselectAll();
                        if (this.mode === 'connect') {
                            this.resetConnectingDevice();
                        }
                        // Close any open panels
                        this.closePropertiesPanel();
                        this.hideSimulationMenu();
                        break;
                    case 't':
                        if (event.ctrlKey) {
                            event.preventDefault();
                            this.toggleTerminal();
                        }
                        break;
                    case 'm':
                        if (event.ctrlKey) {
                            event.preventDefault();
                            this.toggleMonitor();
                        }
                        break;
                    case 'h':
                        if (event.ctrlKey) {
                            event.preventDefault();
                            this.showHelp();
                        }
                        break;
                    case '1':
                        this.setMode('select');
                        break;
                    case '2':
                        this.setMode('connect');
                        break;
                    case '3':
                        this.setMode('move');
                        break;
                    case '4':
                        this.setMode('delete');
                        break;
                }
            }
            
            showHelp() {
                this.showInfoOverlay(
                    'Keyboard Shortcuts',
                    'Quick keyboard commands for efficient network design',
                    `<strong>General:</strong><br>
                    ‚Ä¢ <kbd>Ctrl+T</kbd> - Toggle Terminal<br>
                    ‚Ä¢ <kbd>Ctrl+M</kbd> - Toggle Monitor<br>
                    ‚Ä¢ <kbd>Ctrl+H</kbd> - Show this help<br>
                    ‚Ä¢ <kbd>Delete</kbd> - Delete selected device<br>
                    ‚Ä¢ <kbd>Escape</kbd> - Cancel/Close<br><br>
                    <strong>Modes:</strong><br>
                    ‚Ä¢ <kbd>1</kbd> - Select Mode<br>
                    ‚Ä¢ <kbd>2</kbd> - Connect Mode<br>
                    ‚Ä¢ <kbd>3</kbd> - Move Mode<br>
                    ‚Ä¢ <kbd>4</kbd> - Delete Mode`
                );
            }
            
            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            // Device operations
            selectDevice(device) {
                if (this.selectedDevice) {
                    this.selectedDevice.traverse((child) => {
                        if (child.material && child.userData.originalEmissive !== undefined) {
                            child.material.emissive = child.userData.originalEmissive;
                            delete child.userData.originalEmissive;
                        }
                    });
                }
                
                this.selectedDevice = device;
                
                device.traverse((child) => {
                    if (child.material && child.material.emissive) {
                        child.userData.originalEmissive = child.material.emissive.clone();
                        child.material.emissive = new THREE.Color(0xffd700);
                    }
                });
                
                this.showPropertiesPanel(device);
            }
            
            handleConnect(device) {
                if (!this.connectingDevice) {
                    this.connectingDevice = device;
                    device.traverse((child) => {
                        if (child.material) {
                            child.material.emissive = new THREE.Color(0x00ff00);
                        }
                    });
                } else if (this.connectingDevice !== device) {
                    this.createConnection(this.connectingDevice, device);
                    this.resetConnectingDevice();
                }
            }
            
            resetConnectingDevice() {
                if (this.connectingDevice) {
                    this.connectingDevice.traverse((child) => {
                        if (child.material && child.material.emissive) {
                            child.material.emissive = new THREE.Color(0x000000);
                        }
                    });
                    this.connectingDevice = null;
                }
            }
            
            deleteDevice(device) {
                // Remove connections
                const connectionsToRemove = this.connections.filter(conn => 
                    conn.device1 === device || conn.device2 === device
                );
                
                connectionsToRemove.forEach(conn => {
                    this.scene.remove(conn.line);
                    const index = this.connections.indexOf(conn);
                    if (index > -1) {
                        this.connections.splice(index, 1);
                    }
                });
                
                // Remove device
                this.scene.remove(device);
                const deviceIndex = this.devices.indexOf(device);
                if (deviceIndex > -1) {
                    this.devices.splice(deviceIndex, 1);
                }
                
                if (this.selectedDevice === device) {
                    this.selectedDevice = null;
                    this.closePropertiesPanel();
                }
                
                this.showNotification('Device removed');
            }
            
            findParentDevice(object) {
                while (object.parent && !this.devices.includes(object)) {
                    object = object.parent;
                }
                return object;
            }
            
            // UI methods
            setMode(mode) {
                this.mode = mode;
                
                // Update button states
                document.querySelectorAll('.mode-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.textContent.toLowerCase() === mode) {
                        btn.classList.add('active');
                    }
                });
                
                this.resetConnectingDevice();
                
                // Update cursor style based on mode
                switch(mode) {
                    case 'delete':
                        document.body.style.cursor = 'crosshair';
                        break;
                    case 'connect':
                        document.body.style.cursor = 'cell';
                        break;
                    default:
                        document.body.style.cursor = 'default';
                }
                
                this.showNotification(`Mode: ${mode.charAt(0).toUpperCase() + mode.slice(1)}`);
            }
            
            showPropertiesPanel(device) {
                const panel = document.getElementById('properties-panel');
                panel.style.display = 'block';
                
                document.getElementById('device-name').value = device.userData.name;
                document.getElementById('device-ip').value = device.userData.ip;
                document.getElementById('device-subnet').value = device.userData.subnet;
                document.getElementById('device-status').value = device.userData.status;
            }
            
            closePropertiesPanel() {
                document.getElementById('properties-panel').style.display = 'none';
            }
            
            updateDeviceLabel(device) {
                if (device.userData.label) {
                    device.remove(device.userData.label);
                }
                this.addDeviceLabel(device);
            }
            
            saveProperties() {
                if (!this.selectedDevice) return;
                
                this.selectedDevice.userData.name = document.getElementById('device-name').value;
                this.selectedDevice.userData.ip = document.getElementById('device-ip').value;
                this.selectedDevice.userData.subnet = document.getElementById('device-subnet').value;
                this.selectedDevice.userData.status = document.getElementById('device-status').value;
                
                // Update label
                this.updateDeviceLabel(this.selectedDevice);
                
                this.showNotification('Properties saved successfully');
                
                // Log to terminal if open
                if (document.getElementById('terminal').style.display !== 'none') {
                    const terminalOutput = document.getElementById('terminal-output');
                    terminalOutput.innerHTML += `<div style="color: #4CAF50;">[Config] ${this.selectedDevice.userData.name} updated - IP: ${this.selectedDevice.userData.ip}</div>`;
                    terminalOutput.scrollTop = terminalOutput.scrollHeight;
                }
            }
            
            // Simulation controls
            runSimulation() {
                if (this.connections.length === 0) {
                    this.showNotification('No connections to simulate', 'warning');
                    return;
                }
                
                const connection = this.connections[Math.floor(Math.random() * this.connections.length)];
                this.animatePacket(connection.device1, connection.device2);
            }
            
            animatePacket(source, target) {
                const packetGeometry = new THREE.SphereGeometry(0.3);
                const packetMaterial = new THREE.MeshPhongMaterial({
                    color: 0xffd700,
                    emissive: 0xffd700,
                    emissiveIntensity: 0.8
                });
                const packet = new THREE.Mesh(packetGeometry, packetMaterial);
                packet.position.copy(source.position);
                this.scene.add(packet);
                
                const points = [];
                const segments = 50;
                
                for (let i = 0; i <= segments; i++) {
                    const t = i / segments;
                    const point = new THREE.Vector3().lerpVectors(
                        source.position,
                        target.position,
                        t
                    );
                    
                    const midPoint = 0.5;
                    const curveHeight = 3;
                    const curveFactor = 4 * (t - midPoint) * (t - midPoint);
                    point.y += curveHeight * (1 - curveFactor);
                    
                    points.push(point);
                }
                
                const curve = new THREE.CatmullRomCurve3(points);
                const duration = 2000;
                const startTime = Date.now();
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    const position = curve.getPoint(progress);
                    packet.position.copy(position);
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        this.scene.remove(packet);
                        
                        // Flash target
                        target.traverse((child) => {
                            if (child.material) {
                                const originalEmissive = child.material.emissive.clone();
                                child.material.emissive = new THREE.Color(0x00ff00);
                                setTimeout(() => {
                                    child.material.emissive = originalEmissive;
                                }, 300);
                            }
                        });
                    }
                };
                
                animate();
            }
            
            // Camera controls
            zoomIn() {
                this.controls.zoomIn();
            }
            
            zoomOut() {
                this.controls.zoomOut();
            }
            
            resetView() {
                this.camera.position.set(30, 40, 50);
                this.camera.lookAt(0, 0, 0);
                this.controls.reset();
            }
            
            // Utility
            showNotification(message, type = 'info') {
                const notification = document.getElementById('notification');
                notification.textContent = message;
                notification.style.display = 'block';
                
                setTimeout(() => {
                    notification.style.display = 'none';
                }, 3000);
            }
            
            // Professional Features
            toggleTerminal() {
                const terminal = document.getElementById('terminal');
                terminal.style.display = terminal.style.display === 'none' ? 'block' : 'none';
                if (terminal.style.display === 'block') {
                    document.getElementById('terminal-input').focus();
                }
            }
            
            toggleMonitor() {
                const monitor = document.getElementById('network-monitor');
                monitor.style.display = monitor.style.display === 'none' ? 'block' : 'none';
                if (monitor.style.display === 'block') {
                    this.monitor.startMonitoring();
                } else {
                    this.monitor.stopMonitoring();
                }
            }
            
            toggleTutorial() {
                const tutorial = document.getElementById('tutorial-panel');
                tutorial.style.display = tutorial.style.display === 'none' ? 'block' : 'none';
            }
            
            showSimulationMenu() {
                document.getElementById('simulation-menu').style.display = 'block';
            }
            
            // Direct method to show destination dialog without going through simulation menu
            showPacketSendDialog() {
                // Set default packet type to ping
                const packetTypeSelect = document.getElementById('packet-type');
                packetTypeSelect.value = 'ping';
                
                // Show the destination dialog
                if (!this.showDestinationDialog()) {
                    this.showNotification('Please add at least 2 PCs to your network before running a simulation', 'warning');
                }
            }
            
            // Destination PC selection dialog methods
            showDestinationDialog() {
                console.log('Showing destination dialog');
                
                // Populate source and destination dropdowns
                const sourceSelect = document.getElementById('packet-source');
                const destSelect = document.getElementById('packet-destination');
                
                // Clear existing options
                sourceSelect.innerHTML = '';
                destSelect.innerHTML = '';
                
                // Filter to show only PCs (desktop computers AND laptops)
                // Include both desktop and laptop types to ensure all PCs are included
                const pcs = this.devices.filter(d => 
                    d.userData.type === 'desktop' || 
                    d.userData.type === 'laptop'
                );
                
                console.log('Found PCs:', pcs.map(pc => pc.userData.name));
                
                if (pcs.length < 2) {
                    this.showNotification('You need at least 2 PCs to send packets between them', 'warning');
                    return false;
                }
                
                // Add options for each PC
                pcs.forEach(pc => {
                    const sourceOption = document.createElement('option');
                    sourceOption.value = pc.userData.name;
                    sourceOption.textContent = `${pc.userData.name} (${pc.userData.ip || 'No IP'})`;  // Handle case where IP is not set
                    sourceSelect.appendChild(sourceOption);
                    
                    const destOption = document.createElement('option');
                    destOption.value = pc.userData.name;
                    destOption.textContent = `${pc.userData.name} (${pc.userData.ip || 'No IP'})`;  // Handle case where IP is not set
                    destSelect.appendChild(destOption);
                });
                
                // Make sure source and destination are different by default
                if (pcs.length >= 2 && sourceSelect.options[0].value === destSelect.options[0].value) {
                    destSelect.selectedIndex = 1;
                }
                
                // Show the dialog with high z-index to ensure it's visible
                const dialog = document.getElementById('destination-dialog');
                dialog.style.display = 'block';
                dialog.style.zIndex = '2000'; // Ensure it's above everything else
                
                return true;
            }
            
            closeDestinationDialog() {
                document.getElementById('destination-dialog').style.display = 'none';
            }
            
            startPacketTransmission() {
                console.log('Starting packet transmission');
                
                // Get values from the dialog
                const sourceName = document.getElementById('packet-source').value;
                const destName = document.getElementById('packet-destination').value;
                const packetType = document.getElementById('packet-type').value;
                
                console.log(`Selected source: ${sourceName}, destination: ${destName}, type: ${packetType}`);
                
                // Validate that we have source and destination selected
                if (!sourceName || !destName) {
                    this.showNotification('Please select both source and destination PCs', 'warning');
                    return;
                }
                
                // Find the source and destination devices
                const source = this.devices.find(d => d.userData.name === sourceName);
                const destination = this.devices.find(d => d.userData.name === destName);
                
                // Double-check that both devices exist
                if (!source || !destination) {
                    this.showNotification('Could not find selected devices', 'warning');
                    return;
                }
                
                if (source === destination) {
                    this.showNotification('Source and destination cannot be the same', 'warning');
                    return;
                }
                
                // Open the terminal if it's not already open
                if (document.getElementById('terminal').style.display === 'none') {
                    this.toggleTerminal();
                }
                
                // Clear any previous simulation indicators
                this.clearAllSimulationEffects();
                
                // Build routing tables for all routers in the network
                this.buildAllRoutingTables();
                
                // Find the path between source and destination PCs
                const path = this.findNetworkPath(source, destination);
                
                if (!path || path.length === 0) {
                    this.showNotification('No valid network path found between PCs', 'warning');
                    this.closeDestinationDialog();
                    return;
                }
                
                // Close the dialog
                this.closeDestinationDialog();
                
                // Show information about the network path being used
                const pathDescription = this.describeNetworkPath(path);
                this.showInfoOverlay(
                    `Packet Transmission: ${source.userData.name} to ${destination.userData.name}`,
                    `The packet will travel through ${path.length - 2} intermediate devices.`,
                    pathDescription
                );
                
                // Start packet transmission based on the network topology
                this.packetSimulator.simulateTransmission(source, destination, packetType, path);
            }
            
            // Clear any active simulation effects
            clearAllSimulationEffects() {
                // Reset all connection colors
                this.connections.forEach(conn => {
                    if (conn.originalColor) {
                        conn.line.material.color = conn.originalColor;
                        conn.line.material.emissive = conn.originalEmissive;
                        conn.line.material.emissiveIntensity = conn.originalIntensity;
                        delete conn.originalColor;
                        delete conn.originalEmissive;
                        delete conn.originalIntensity;
                    }
                });
                
                // Remove any processing indicators or packets
                this.scene.children.forEach(object => {
                    // Check if this is a simulation object (packet or indicator)
                    if (object.userData && object.userData.simulationObject) {
                        this.scene.remove(object);
                    }
                });
            }
            
            // Generate a description of the network path
            describeNetworkPath(path) {
                let description = '<strong>Network Path:</strong><br>';
                
                // Analyze the devices in the path
                const switchCount = path.filter(d => NetworkSimulator.DEVICE_TYPES.LAYER2_DEVICE.includes(d.userData.type)).length;
                const routerCount = path.filter(d => NetworkSimulator.DEVICE_TYPES.LAYER3_DEVICE.includes(d.userData.type)).length;
                
                // Add information about the network infrastructure
                description += `‚Ä¢ Path includes ${routerCount} router(s) and ${switchCount} switch(es)<br>`;
                
                // Check if crossing subnet boundaries
                const sourceSubnet = this.getSubnetPrefix(path[0].userData.ip, path[0].userData.subnet);
                const destSubnet = this.getSubnetPrefix(path[path.length-1].userData.ip, path[path.length-1].userData.subnet);
                
                if (sourceSubnet !== destSubnet) {
                    description += `‚Ä¢ Crossing subnet boundary: ${sourceSubnet} ‚Üí ${destSubnet}<br>`;
                    description += `‚Ä¢ Layer 3 (IP) routing required<br>`;
                } else {
                    description += `‚Ä¢ Communication within same subnet: ${sourceSubnet}<br>`;
                    description += `‚Ä¢ Layer 2 (MAC) switching sufficient<br>`;
                }
                
                // List all hops in the path
                description += '<br><strong>Hop by Hop:</strong><br>';
                path.forEach((device, index) => {
                    const deviceType = device.userData.type;
                    let roleDescription = '';
                    
                    if (index === 0) {
                        roleDescription = 'Source PC';
                    } else if (index === path.length - 1) {
                        roleDescription = 'Destination PC';
                    } else if (NetworkSimulator.DEVICE_TYPES.LAYER3_DEVICE.includes(deviceType)) {
                        roleDescription = 'IP Router';
                    } else if (NetworkSimulator.DEVICE_TYPES.LAYER2_DEVICE.includes(deviceType)) {
                        roleDescription = 'MAC Switch';
                    } else {
                        roleDescription = deviceType.charAt(0).toUpperCase() + deviceType.slice(1);
                    }
                    
                    description += `${index + 1}. ${device.userData.name} (${roleDescription})`;
                    if (device.userData.ip) {
                        description += ` - ${device.userData.ip}`;
                    }
                    description += '<br>';
                });
                
                return description;
            }
            
            // Find a valid network path between source PC and destination PC
            findNetworkPath(sourcePc, destinationPc) {
                // Make sure we have built routing tables
                this.buildAllRoutingTables();
                
                // If directly connected (on the same switch), return simple path
                const directConnection = this.connections.find(conn => 
                    (conn.device1 === sourcePc && conn.device2 === destinationPc) ||
                    (conn.device1 === destinationPc && conn.device2 === sourcePc)
                );
                
                if (directConnection) {
                    return [sourcePc, destinationPc];
                }
                
                // Initialize path-finding structures
                const queue = [{ device: sourcePc, path: [sourcePc] }];
                const visited = new Set([sourcePc]);
                
                // For tracking the next hop from routers
                const routerNextHops = new Map();
                
                while (queue.length > 0) {
                    const { device, path } = queue.shift();
                    
                    // Get all directly connected devices
                    const connectedDevices = this.getConnectedDevices(device);
                    
                    for (const connectedDevice of connectedDevices) {
                        // If we reached the destination PC, we're done
                        if (connectedDevice === destinationPc) {
                            return [...path, destinationPc];
                        }
                        
                        // Skip if we've already visited this device
                        if (visited.has(connectedDevice)) continue;
                        
                        // Determine whether we can route through this device
                        let canRoute = false;
                        let shouldQueue = true;
                        
                        // Different routing logic based on device type
                        if (NetworkSimulator.DEVICE_TYPES.LAYER3_DEVICE.includes(connectedDevice.userData.type)) {
                            // Router: check routing table for destination PC's network
                            canRoute = true; // Routers can forward packets
                            
                            // Get the router's next hop for destination PC's IP
                            const route = this.lookupRouteForDestination(connectedDevice, destinationPc.userData.ip);
                            
                            if (route) {
                                // Store the next hop information for this router
                                routerNextHops.set(connectedDevice, {
                                    nextHopName: route.nextHop,
                                    interfaceId: route.interface
                                });
                            } else {
                                // This router doesn't know how to reach the destination
                                canRoute = false;
                            }
                        } 
                        else if (NetworkSimulator.DEVICE_TYPES.LAYER2_DEVICE.includes(connectedDevice.userData.type)) {
                            // Switch: can only forward within the same subnet
                            // Check if the switch is connected to any device in the same subnet as the destination
                            const switchConnections = this.getConnectedDevices(connectedDevice);
                            const destSubnet = this.getSubnetPrefix(destinationPc.userData.ip, destinationPc.userData.subnet);
                            
                            // Check if any connected device is in the same subnet as the destination
                            const hasDeviceInDestSubnet = switchConnections.some(dev => {
                                // Skip non-end devices - we're looking for hosts in the same subnet
                                if (!dev.userData.ip) return false;
                                
                                const devSubnet = this.getSubnetPrefix(dev.userData.ip, dev.userData.subnet);
                                return devSubnet === destSubnet;
                            });
                            
                            canRoute = hasDeviceInDestSubnet;
                        } 
                        else if (NetworkSimulator.DEVICE_TYPES.END_DEVICE.includes(connectedDevice.userData.type)) {
                            // End devices can't route packets unless they're the destination
                            canRoute = false;
                            shouldQueue = false; // Don't explore through other end devices
                        } 
                        else {
                            // Other devices (cloud, wireless) can generally route
                            canRoute = true;
                        }
                        
                        // Add to the search queue if we can route through this device
                        if (canRoute && shouldQueue) {
                            visited.add(connectedDevice);
                            queue.push({
                                device: connectedDevice,
                                path: [...path, connectedDevice]
                            });
                        }
                    }
                }
                
                // If we've examined all possible paths and not found a route, return null
                return null;
            }
            
            // Get all devices directly connected to the given device
            getConnectedDevices(device) {
                const connectedDevices = [];
                
                this.connections.forEach(conn => {
                    if (conn.device1 === device) {
                        connectedDevices.push(conn.device2);
                    } else if (conn.device2 === device) {
                        connectedDevices.push(conn.device1);
                    }
                });
                
                return connectedDevices;
            }
            
            // Check if packets can be routed from previousDevice through currentDevice
            canRouteThrough(previousDevice, currentDevice) {
                const prevType = previousDevice.userData.type;
                const currType = currentDevice.userData.type;
                
                // End devices can only send/receive, not route
                if (NetworkSimulator.DEVICE_TYPES.END_DEVICE.includes(currType)) {
                    return false;
                }
                
                // Layer 2 devices (switches) can only route within the same subnet
                if (NetworkSimulator.DEVICE_TYPES.LAYER2_DEVICE.includes(currType)) {
                    // Check if we're crossing subnet boundaries
                    const prevSubnet = this.getSubnetPrefix(previousDevice.userData.ip, previousDevice.userData.subnet);
                    
                    // For connected end devices
                    const connectedDevices = this.getConnectedDevices(currentDevice);
                    for (const device of connectedDevices) {
                        // Skip non-end devices when checking subnets for switches
                        if (!NetworkSimulator.DEVICE_TYPES.END_DEVICE.includes(device.userData.type)) {
                            continue;
                        }
                        
                        const deviceSubnet = this.getSubnetPrefix(device.userData.ip, device.userData.subnet);
                        if (deviceSubnet !== prevSubnet) {
                            // Different subnet, switch can't route between them
                            return false;
                        }
                    }
                    
                    return true;
                }
                
                // Layer 3 devices (routers) can route between subnets
                if (NetworkSimulator.DEVICE_TYPES.LAYER3_DEVICE.includes(currType)) {
                    return true; // Routers can connect any network
                }
                
                // Wireless access points behave like switches but have their own subnet
                if (NetworkSimulator.DEVICE_TYPES.WIRELESS.includes(currType)) {
                    return true;
                }
                
                // Cloud/WAN can route everything
                if (NetworkSimulator.DEVICE_TYPES.WAN.includes(currType)) {
                    return true;
                }
                
                return false;
            }
            
            // Get the subnet prefix from an IP and subnet mask
            getSubnetPrefix(ip, subnetMask) {
                if (!ip || !subnetMask) {
                    return null;
                }
                
                // Parse IP and subnet mask
                const ipParts = ip.split('.').map(Number);
                const maskParts = subnetMask.split('.').map(Number);
                
                if (ipParts.length !== 4 || maskParts.length !== 4) {
                    return null;
                }
                
                // Calculate network address
                const networkParts = ipParts.map((part, i) => part & maskParts[i]);
                return networkParts.join('.');
            }
            
            hideSimulationMenu() {
                document.getElementById('simulation-menu').style.display = 'none';
            }
            
            switchMonitorTab(tab) {
                // Update tab buttons
                document.querySelectorAll('.monitor-tab').forEach(btn => {
                    btn.classList.remove('active');
                });
                event.target.classList.add('active');
                
                // Show/hide views
                document.querySelectorAll('.monitor-view').forEach(view => {
                    view.style.display = 'none';
                });
                document.getElementById(`${tab}-view`).style.display = 'block';
                
                // Update content
                this.monitor.updateTab(tab);
            }
            
            runSimulation(type) {
                // Hide the simulation menu
                this.hideSimulationMenu();
                
                // IMPORTANT: For ANY simulation type that involves packet transmission,
                // we MUST show the destination dialog first
                
                // Set the packet type in the dialog based on simulation type
                const packetTypeSelect = document.getElementById('packet-type');
                
                // Set default packet type based on simulation type
                if (type === 'ping') {
                    packetTypeSelect.value = 'ping';
                } else if (type === 'tcp-handshake') {
                    packetTypeSelect.value = 'tcp';
                } else if (type === 'traceroute') {
                    packetTypeSelect.value = 'ping';
                } else if (type === 'arp') {
                    packetTypeSelect.value = 'ping';
                } else if (type === 'dns') {
                    packetTypeSelect.value = 'udp';
                }
                
                // Special case for DHCP (doesn't need source/destination selection)
                if (type === 'dhcp') {
                    this.packetSimulator.simulateDHCP();
                    return;
                }
                
                // For all other simulation types, always show the destination dialog
                if (!this.showDestinationDialog()) {
                    this.showNotification('Please add at least 2 PCs to your network before running a simulation', 'warning');
                    return; // Not enough PCs
                }
            }
            
            startTutorial(type) {
                this.toggleTutorial();
                this.tutorialSystem.startTutorial(type);
            }
            
            showInfoOverlay(title, description, details) {
                document.getElementById('info-title').textContent = title;
                document.getElementById('info-description').textContent = description;
                document.getElementById('info-details').innerHTML = details;
                document.getElementById('info-overlay').style.display = 'flex';
            }
            
            closeInfoOverlay() {
                document.getElementById('info-overlay').style.display = 'none';
            }
            
            // Documentation
            showDocumentation() {
                const docsContent = document.getElementById('docs-content');
                const docsPanel = document.getElementById('network-docs');
                
                // Generate network documentation
                docsContent.innerHTML = `
                    <h3 style="margin-bottom: 20px;">Network Topology Documentation</h3>
                    
                    <h4>Overview</h4>
                    <p>This document provides an overview of the current network topology, including devices, connections, and configuration.</p>
                    
                    <h4>Network Devices (${this.devices.length})</h4>
                    <ul style="list-style-type: none; padding-left: 0;">
                        ${this.devices.map(d => `
                            <li style="margin-bottom: 10px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 5px;">
                                <strong>${d.userData.name}</strong> (${d.userData.type})<br>
                                IP: ${d.userData.ip}/${d.userData.subnet}<br>
                                Status: ${d.userData.status}
                            </li>
                        `).join('')}
                    </ul>
                    
                    <h4>Connections (${this.connections.length})</h4>
                    <ul style="list-style-type: none; padding-left: 0;">
                        ${this.connections.map((c, i) => `
                            <li style="margin-bottom: 5px;">
                                ${i+1}. ${c.device1.userData.name} ‚ü∑ ${c.device2.userData.name}
                            </li>
                        `).join('')}
                    </ul>
                    
                    <h4>Network Diagram</h4>
                    <p>A visual representation of the network is available in the main view. The documentation reflects the current state as of ${new Date().toLocaleString()}.</p>
                `;
                
                // Show the documentation panel
                docsPanel.style.display = 'block';
            }
            
            closeDocumentation() {
                document.getElementById('network-docs').style.display = 'none';
            }
            
            // Enhanced device info with educational content
            getDeviceInfo(device) {
                const info = {
                    desktop: {
                        name: 'Desktop PC',
                        description: 'End-user device that connects to the network',
                        details: `‚Ä¢ Layer: Application Layer (Layer 7)
‚Ä¢ Common Protocols: HTTP, FTP, SMTP, DNS
‚Ä¢ Network Interface: Ethernet/Wi-Fi
‚Ä¢ Typical IP: Dynamic (DHCP) or Static
‚Ä¢ Role: Client device for accessing network resources`
                    },
                    laptop: {
                        name: 'Laptop',
                        description: 'Portable computer with wireless capabilities',
                        details: `‚Ä¢ Layer: Application Layer (Layer 7)
‚Ä¢ Connection: Usually Wi-Fi, can use Ethernet
‚Ä¢ Protocols: Same as desktop PC
‚Ä¢ Mobility: Roams between access points
‚Ä¢ Power: Battery-powered, power-saving features`
                    },
                    server: {
                        name: 'Server',
                        description: 'Provides services to client devices',
                        details: `‚Ä¢ Layer: Application Layer (Layer 7)
‚Ä¢ Services: Web, Database, File, DNS, DHCP
‚Ä¢ Connection: High-speed Ethernet (1-10 Gbps)
‚Ä¢ IP: Static configuration
‚Ä¢ Features: Redundancy, load balancing`
                    },
                    router: {
                        name: 'Router',
                        description: 'Routes packets between different networks',
                        details: `‚Ä¢ Layer: Network Layer (Layer 3)
‚Ä¢ Key Functions: IP routing, NAT, DHCP server
‚Ä¢ Routing Protocols: RIP, OSPF, BGP
‚Ä¢ Interfaces: Multiple (WAN/LAN)
‚Ä¢ Role: Connects networks and forwards packets`
                    },
                    switch: {
                        name: 'Switch',
                        description: 'Connects devices within a local network',
                        details: `‚Ä¢ Layer: Data Link Layer (Layer 2)
‚Ä¢ Key Functions: MAC address learning, Frame forwarding
‚Ä¢ Technology: Store-and-forward, Cut-through
‚Ä¢ Features: VLANs, Port security, STP
‚Ä¢ Role: Creates collision domains, extends LANs`
                    },
                    firewall: {
                        name: 'Firewall',
                        description: 'Network security device that monitors traffic',
                        details: `‚Ä¢ Layer: Can operate at Layers 3-7
‚Ä¢ Functions: Packet filtering, Stateful inspection
‚Ä¢ Rules: Allow/Deny based on IP, Port, Protocol
‚Ä¢ Types: Hardware, Software, Cloud-based
‚Ä¢ Features: IDS/IPS, VPN, Content filtering`
                    },
                    wireless: {
                        name: 'Wireless Access Point',
                        description: 'Provides Wi-Fi connectivity to wireless devices',
                        details: `‚Ä¢ Layer: Data Link Layer (Layer 2)
‚Ä¢ Standards: 802.11a/b/g/n/ac/ax (Wi-Fi 6)
‚Ä¢ Frequencies: 2.4 GHz, 5 GHz, 6 GHz
‚Ä¢ Security: WPA2/WPA3, Enterprise authentication
‚Ä¢ Features: Multiple SSIDs, Guest networks`
                    },
                    hub: {
                        name: 'Hub',
                        description: 'Basic network device that broadcasts to all ports',
                        details: `‚Ä¢ Layer: Physical Layer (Layer 1)
‚Ä¢ Function: Signal repeater, broadcasts to all ports
‚Ä¢ Collision Domain: Single shared domain
‚Ä¢ Outdated: Replaced by switches in modern networks
‚Ä¢ Limitations: Security risks, bandwidth sharing`
                    },
                    cloud: {
                        name: 'Cloud/Internet',
                        description: 'Represents external networks or cloud services',
                        details: `‚Ä¢ Type: WAN connection to Internet/Cloud
‚Ä¢ Services: SaaS, PaaS, IaaS
‚Ä¢ Protocols: HTTP/HTTPS, VPN, API calls
‚Ä¢ Benefits: Scalability, Flexibility, Cost-effective
‚Ä¢ Considerations: Latency, Security, Bandwidth`
                    }
                };
                
                return info[device.userData.type] || { name: 'Network Device', description: '', details: '' };
            }
            
            // Animation loop
            animate() {
                requestAnimationFrame(() => this.animate());
                
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
                
                // Rotate wireless devices
                this.devices.forEach(device => {
                    if (device.userData.type === 'wireless') {
                        device.rotation.y += 0.01;
                    }
                });
                
                // Pulse connections - subtle pulse for professional look
                const time = Date.now() * 0.001;
                this.connections.forEach(conn => {
                    if (conn.line.material) {
                        conn.line.material.emissiveIntensity = 0.2 + Math.sin(time * 1.5) * 0.1;
                    }
                });
            }
        }
        
        // Camera Controls
        class CameraControls {
            constructor(camera, domElement) {
                this.camera = camera;
                this.domElement = domElement;
                this.enabled = true;
                
                this.rotateSpeed = 1.0;
                this.zoomSpeed = 1.2;
                
                this.mouseDown = false;
                this.mouseX = 0;
                this.mouseY = 0;
                
                this.theta = 45;
                this.phi = 60;
                this.radius = 70;
                
                this.target = new THREE.Vector3(0, -10, 0);
                
                this.domElement.addEventListener('mousedown', this.onMouseDown.bind(this));
                this.domElement.addEventListener('mouseup', this.onMouseUp.bind(this));
                this.domElement.addEventListener('mousemove', this.onMouseMove.bind(this));
                this.domElement.addEventListener('wheel', this.onMouseWheel.bind(this));
                
                this.update();
            }
            
            onMouseDown(event) {
                if (!this.enabled || event.button !== 2) return;
                
                this.mouseDown = true;
                this.mouseX = event.clientX;
                this.mouseY = event.clientY;
            }
            
            onMouseUp() {
                this.mouseDown = false;
            }
            
            onMouseMove(event) {
                if (!this.enabled || !this.mouseDown) return;
                
                const deltaX = event.clientX - this.mouseX;
                const deltaY = event.clientY - this.mouseY;
                
                this.theta -= deltaX * 0.5;
                this.phi = Math.max(10, Math.min(170, this.phi - deltaY * 0.5));
                
                this.mouseX = event.clientX;
                this.mouseY = event.clientY;
                
                this.update();
            }
            
            onMouseWheel(event) {
                if (!this.enabled) return;
                event.preventDefault();
                
                if (event.deltaY < 0) {
                    this.radius *= 0.9;
                } else {
                    this.radius *= 1.1;
                }
                
                this.radius = Math.max(20, Math.min(150, this.radius));
                this.update();
            }
            
            update() {
                const phi = this.phi * Math.PI / 180;
                const theta = this.theta * Math.PI / 180;
                
                this.camera.position.x = this.radius * Math.sin(phi) * Math.cos(theta);
                this.camera.position.y = this.radius * Math.cos(phi) - 10;
                this.camera.position.z = this.radius * Math.sin(phi) * Math.sin(theta);
                
                this.camera.lookAt(this.target);
            }
            
            zoomIn() {
                this.radius *= 0.8;
                this.radius = Math.max(20, this.radius);
                this.update();
            }
            
            zoomOut() {
                this.radius *= 1.2;
                this.radius = Math.min(150, this.radius);
                this.update();
            }
            
            reset() {
                this.theta = 45;
                this.phi = 60;
                this.radius = 70;
                this.update();
            }
        }
        
        // Network Terminal Class
        class NetworkTerminal {
            constructor(simulator) {
                this.sim = simulator;
                this.history = [];
                this.historyIndex = 0;
                this.commands = {
                    'help': this.help.bind(this),
                    'ping': this.ping.bind(this),
                    'traceroute': this.traceroute.bind(this),
                    'show': this.show.bind(this),
                    'config': this.config.bind(this),
                    'clear': this.clear.bind(this),
                    'connect': this.connect.bind(this),
                    'disconnect': this.disconnect.bind(this),
                    'analyze': this.analyze.bind(this)
                };
                
                this.setupTerminal();
            }
            
            setupTerminal() {
                const input = document.getElementById('terminal-input');
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        this.executeCommand(input.value);
                        this.history.push(input.value);
                        this.historyIndex = this.history.length;
                        input.value = '';
                    } else if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        if (this.historyIndex > 0) {
                            this.historyIndex--;
                            input.value = this.history[this.historyIndex];
                        }
                    } else if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        if (this.historyIndex < this.history.length - 1) {
                            this.historyIndex++;
                            input.value = this.history[this.historyIndex];
                        } else {
                            this.historyIndex = this.history.length;
                            input.value = '';
                        }
                    } else if (e.key === 'Tab') {
                        e.preventDefault();
                        this.autocomplete(input);
                    }
                });
                
                // Add welcome message
                const output = document.getElementById('terminal-output');
                output.innerHTML = `<div style="color: #4CAF50;">Network Simulator Terminal v2.0</div>
<div>Type 'help' for available commands or 'tutorial' for interactive guide.</div>
<div>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</div>`;
            }
            
            autocomplete(input) {
                const value = input.value;
                const parts = value.split(' ');
                const cmd = parts[0];
                
                // Command autocomplete
                if (parts.length === 1) {
                    const matches = Object.keys(this.commands).filter(c => c.startsWith(cmd));
                    if (matches.length === 1) {
                        input.value = matches[0] + ' ';
                    } else if (matches.length > 1) {
                        const output = document.getElementById('terminal-output');
                        output.innerHTML += `<div style="color: #999;">Available: ${matches.join(', ')}</div>`;
                        output.scrollTop = output.scrollHeight;
                    }
                }
                
                // Device name autocomplete
                else if (['ping', 'config', 'connect', 'disconnect'].includes(cmd) && parts.length === 2) {
                    const partial = parts[1];
                    const deviceNames = this.sim.devices.map(d => d.userData.name);
                    const matches = deviceNames.filter(n => n.startsWith(partial));
                    
                    if (matches.length === 1) {
                        input.value = `${cmd} ${matches[0]} `;
                    } else if (matches.length > 1) {
                        const output = document.getElementById('terminal-output');
                        output.innerHTML += `<div style="color: #999;">Devices: ${matches.join(', ')}</div>`;
                        output.scrollTop = output.scrollHeight;
                    }
                }
            }
            
            executeCommand(input) {
                const output = document.getElementById('terminal-output');
                output.innerHTML += `<div style="color: #4CAF50;">admin@network:~$ ${input}</div>`;
                
                const [cmd, ...args] = input.trim().split(' ');
                
                if (this.commands[cmd]) {
                    const result = this.commands[cmd](args);
                    output.innerHTML += `<div>${result}</div>`;
                } else if (input.trim() === '') {
                    // Empty command
                } else {
                    output.innerHTML += `<div style="color: #f44336;">Command not found: ${cmd}. Type 'help' for available commands.</div>`;
                }
                
                output.scrollTop = output.scrollHeight;
            }
            
            help() {
                return `<div style="color: #4CAF50;">Network Simulator Terminal - Available Commands:</div>
<div style="color: #999;">‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</div>
<div><span style="color: #4CAF50;">Network Testing:</span></div>
<div>  ping [device]           - Ping a device by name or IP</div>
<div>  traceroute [device]     - Trace route to destination</div>
<div>  arp -a                  - Show ARP table</div>
<div>  netstat                 - Show network statistics</div>

<div><span style="color: #4CAF50;">Device Management:</span></div>
<div>  show devices            - List all network devices</div>
<div>  show connections        - List all connections</div>
<div>  show routing            - Display routing table</div>
<div>  show vlans              - Display VLAN configuration</div>
<div>  config [device]         - Configure a device</div>
<div>  connect [d1] [d2]       - Connect two devices</div>
<div>  disconnect [d1] [d2]    - Disconnect two devices</div>

<div><span style="color: #4CAF50;">Network Analysis:</span></div>
<div>  analyze network         - Analyze network topology</div>
<div>  analyze performance     - Test network performance</div>
<div>  analyze security        - Security assessment</div>
<div>  bandwidth [d1] [d2]     - Test bandwidth between devices</div>

<div><span style="color: #4CAF50;">Educational:</span></div>
<div>  tutorial                - Start interactive tutorial</div>
<div>  explain [protocol]      - Explain network protocol</div>
<div>  simulate [scenario]     - Run simulation scenario</div>

<div><span style="color: #4CAF50;">Utilities:</span></div>
<div>  clear                   - Clear terminal screen</div>
<div>  export                  - Export network configuration</div>
<div>  save [name]             - Save current topology</div>
<div>  load [name]             - Load saved topology</div>
<div style="color: #999;">‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</div>
<div style="color: #999;">Tip: Use Tab for command/device autocomplete</div>`;
            }
            
            executeCommand(input) {
                const output = document.getElementById('terminal-output');
                output.innerHTML += `<div style="color: #4CAF50;">admin@network:~$ ${input}</div>`;
                
                const [cmd, ...args] = input.trim().split(' ');
                
                // Extended command set
                const extendedCommands = {
                    'arp': () => this.showARPTable(args),
                    'netstat': () => this.showNetstat(),
                    'bandwidth': () => this.testBandwidth(args),
                    'tutorial': () => this.startInteractiveTutorial(),
                    'explain': () => this.explainProtocol(args),
                    'simulate': () => this.runScenario(args),
                    'save': () => this.saveTopology(args),
                    'load': () => this.loadTopology(args),
                    'export': () => {
                        this.sim.exportNetwork();
                        return '<div style="color: #4CAF50;">Network exported to file</div>';
                    }
                };
                
                // Check extended commands first
                if (extendedCommands[cmd]) {
                    const result = extendedCommands[cmd]();
                    output.innerHTML += `<div>${result}</div>`;
                } else if (this.commands[cmd]) {
                    const result = this.commands[cmd](args);
                    output.innerHTML += `<div>${result}</div>`;
                } else if (input.trim() === '') {
                    // Empty command
                } else {
                    output.innerHTML += `<div style="color: #f44336;">Command not found: ${cmd}. Type 'help' for available commands.</div>`;
                }
                
                output.scrollTop = output.scrollHeight;
            }
            
            showARPTable(args) {
                if (args[0] === '-a') {
                    let arpTable = '<div style="color: #4CAF50;">ARP Table:</div>';
                    arpTable += '<div>Internet Address      Physical Address      Type</div>';
                    
                    this.sim.devices.forEach(device => {
                        arpTable += `<div>${device.userData.ip.padEnd(20)} ${device.userData.mac.padEnd(20)} Dynamic</div>`;
                    });
                    
                    return arpTable;
                }
                return '<div style="color: #f44336;">Usage: arp -a</div>';
            }
            
            showNetstat() {
                return `<div style="color: #4CAF50;">Network Statistics:</div>
<div>Active Connections:</div>
<div>Proto  Local Address          Foreign Address        State</div>
<div>TCP    192.168.1.100:52346    192.168.1.1:80        ESTABLISHED</div>
<div>TCP    192.168.1.100:52347    52.84.228.25:443      ESTABLISHED</div>
<div>UDP    192.168.1.100:68       192.168.1.1:67        LISTENING</div>
<div></div>
<div>Interface Statistics:</div>
<div>                       Received            Sent</div>
<div>Bytes                  ${Math.floor(Math.random() * 1000000)}              ${Math.floor(Math.random() * 500000)}</div>
<div>Unicast packets        ${Math.floor(Math.random() * 10000)}               ${Math.floor(Math.random() * 5000)}</div>
<div>Non-unicast packets    ${Math.floor(Math.random() * 100)}                 ${Math.floor(Math.random() * 50)}</div>
<div>Discards               0                   0</div>
<div>Errors                 0                   0</div>`;
            }
            
            testBandwidth(args) {
                if (args.length < 2) {
                    return '<div style="color: #f44336;">Usage: bandwidth [device1] [device2]</div>';
                }
                
                const device1 = this.sim.devices.find(d => d.userData.name === args[0]);
                const device2 = this.sim.devices.find(d => d.userData.name === args[1]);
                
                if (!device1 || !device2) {
                    return '<div style="color: #f44336;">One or both devices not found</div>';
                }
                
                // Check if connected
                const connected = this.sim.connections.some(c => 
                    (c.device1 === device1 && c.device2 === device2) ||
                    (c.device1 === device2 && c.device2 === device1)
                );
                
                if (!connected) {
                    return '<div style="color: #f44336;">Devices are not connected</div>';
                }
                
                // Simulate bandwidth test
                const bandwidth = 900 + Math.random() * 100; // 900-1000 Mbps
                const latency = 0.1 + Math.random() * 0.9; // 0.1-1.0 ms
                const jitter = Math.random() * 0.5; // 0-0.5 ms
                
                return `<div style="color: #4CAF50;">Bandwidth Test Results:</div>
<div>Testing ${device1.userData.name} <--> ${device2.userData.name}</div>
<div>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</div>
<div>[ ID] Interval           Transfer     Bandwidth</div>
<div>[  3] 0.00-1.00 sec      117 MBytes   ${bandwidth.toFixed(1)} Mbits/sec</div>
<div>[  3] 1.00-2.00 sec      118 MBytes   ${(bandwidth + 10).toFixed(1)} Mbits/sec</div>
<div>[  3] 2.00-3.00 sec      116 MBytes   ${(bandwidth - 10).toFixed(1)} Mbits/sec</div>
<div>‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</div>
<div>[  3] 0.00-3.00 sec      351 MBytes   ${bandwidth.toFixed(1)} Mbits/sec</div>
<div>Latency: ${latency.toFixed(2)} ms</div>
<div>Jitter: ${jitter.toFixed(2)} ms</div>
<div>Packet Loss: 0.0%</div>`;
            }
            
            explainProtocol(args) {
                if (args.length === 0) {
                    return '<div style="color: #f44336;">Usage: explain [protocol]</div><div>Available: tcp, udp, ip, icmp, arp, dhcp, dns, http, https, ssh, ftp</div>';
                }
                
                const protocols = {
                    tcp: {
                        name: 'TCP (Transmission Control Protocol)',
                        layer: 'Transport Layer (Layer 4)',
                        description: 'Provides reliable, ordered, and error-checked delivery of data',
                        features: '‚Ä¢ Connection-oriented\n‚Ä¢ 3-way handshake\n‚Ä¢ Flow control\n‚Ä¢ Congestion control\n‚Ä¢ Retransmission of lost packets',
                        ports: 'Common ports: HTTP(80), HTTPS(443), SSH(22), FTP(21)'
                    },
                    udp: {
                        name: 'UDP (User Datagram Protocol)',
                        layer: 'Transport Layer (Layer 4)',
                        description: 'Provides unreliable, unordered delivery with low overhead',
                        features: '‚Ä¢ Connectionless\n‚Ä¢ No handshake\n‚Ä¢ No delivery guarantee\n‚Ä¢ Lower latency\n‚Ä¢ Good for streaming',
                        ports: 'Common ports: DNS(53), DHCP(67/68), TFTP(69)'
                    },
                    ip: {
                        name: 'IP (Internet Protocol)',
                        layer: 'Network Layer (Layer 3)',
                        description: 'Provides logical addressing and routing of packets',
                        features: '‚Ä¢ IPv4: 32-bit addresses\n‚Ä¢ IPv6: 128-bit addresses\n‚Ä¢ Fragmentation\n‚Ä¢ TTL field\n‚Ä¢ Best-effort delivery',
                        headers: 'Version, IHL, ToS, Length, ID, Flags, Fragment, TTL, Protocol, Checksum, Source, Destination'
                    },
                    arp: {
                        name: 'ARP (Address Resolution Protocol)',
                        layer: 'Between Layer 2 and 3',
                        description: 'Maps IP addresses to MAC addresses',
                        features: '‚Ä¢ Broadcast request\n‚Ä¢ Unicast reply\n‚Ä¢ ARP cache\n‚Ä¢ Gratuitous ARP\n‚Ä¢ Proxy ARP',
                        process: 'Who has IP? ‚Üí IP is at MAC'
                    },
                    dhcp: {
                        name: 'DHCP (Dynamic Host Configuration Protocol)',
                        layer: 'Application Layer (Layer 7)',
                        description: 'Automatically assigns IP addresses to devices',
                        features: '‚Ä¢ DORA process\n‚Ä¢ IP address pools\n‚Ä¢ Lease time\n‚Ä¢ Options (gateway, DNS)\n‚Ä¢ Reservations',
                        process: 'Discover ‚Üí Offer ‚Üí Request ‚Üí Acknowledge'
                    },
                    dns: {
                        name: 'DNS (Domain Name System)',
                        layer: 'Application Layer (Layer 7)',
                        description: 'Translates domain names to IP addresses',
                        features: '‚Ä¢ Hierarchical structure\n‚Ä¢ Recursive queries\n‚Ä¢ Caching\n‚Ä¢ Multiple record types\n‚Ä¢ Load balancing',
                        records: 'A (IPv4), AAAA (IPv6), CNAME, MX, TXT, NS, SOA'
                    }
                };
                
                const protocol = protocols[args[0].toLowerCase()];
                if (!protocol) {
                    return `<div style="color: #f44336;">Unknown protocol: ${args[0]}</div>`;
                }
                
                let output = `<div style="color: #4CAF50;">${protocol.name}</div>`;
                output += `<div style="color: #999;">‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</div>`;
                output += `<div><span style="color: #4CAF50;">Layer:</span> ${protocol.layer}</div>`;
                output += `<div><span style="color: #4CAF50;">Description:</span> ${protocol.description}</div>`;
                output += `<div><span style="color: #4CAF50;">Key Features:</span></div>`;
                output += `<div style="white-space: pre-wrap;">${protocol.features}</div>`;
                
                if (protocol.ports) {
                    output += `<div><span style="color: #4CAF50;">Ports:</span> ${protocol.ports}</div>`;
                }
                if (protocol.process) {
                    output += `<div><span style="color: #4CAF50;">Process:</span> ${protocol.process}</div>`;
                }
                if (protocol.headers) {
                    output += `<div><span style="color: #4CAF50;">Headers:</span> ${protocol.headers}</div>`;
                }
                if (protocol.records) {
                    output += `<div><span style="color: #4CAF50;">Record Types:</span> ${protocol.records}</div>`;
                }
                
                return output;
            }
            
            startInteractiveTutorial() {
                this.sim.toggleTutorial();
                return '<div style="color: #4CAF50;">Opening interactive tutorial panel...</div>';
            }
            
            runScenario(args) {
                if (args.length === 0) {
                    return '<div style="color: #f44336;">Usage: simulate [scenario]</div><div>Available: network-loop, broadcast-storm, vlan-trunk, spanning-tree</div>';
                }
                
                const scenario = args[0];
                switch(scenario) {
                    case 'network-loop':
                        return this.simulateNetworkLoop();
                    case 'broadcast-storm':
                        return this.simulateBroadcastStorm();
                    case 'vlan-trunk':
                        return this.simulateVLANTrunk();
                    case 'spanning-tree':
                        return this.simulateSpanningTree();
                    default:
                        return `<div style="color: #f44336;">Unknown scenario: ${scenario}</div>`;
                }
            }
            
            simulateNetworkLoop() {
                // Check for loops in topology
                const hasLoop = this.sim.checkRedundancy();
                
                if (hasLoop) {
                    // Animate broadcast storm effect
                    this.sim.connections.forEach(conn => {
                        const originalColor = conn.line.material.color.clone();
                        const pulseCount = 10;
                        let pulse = 0;
                        
                        const animatePulse = () => {
                            if (pulse < pulseCount) {
                                conn.line.material.color = pulse % 2 === 0 ? new THREE.Color(0xff0000) : originalColor;
                                conn.line.material.emissiveIntensity = pulse % 2 === 0 ? 0.8 : 0.3;
                                pulse++;
                                setTimeout(animatePulse, 200);
                            } else {
                                conn.line.material.color = originalColor;
                                conn.line.material.emissiveIntensity = 0.3;
                            }
                        };
                        animatePulse();
                    });
                    
                    return `<div style="color: #ff9800;">‚ö†Ô∏è Network Loop Detected!</div>
<div>A switching loop exists in your topology.</div>
<div>This can cause:</div>
<div>‚Ä¢ Broadcast storms</div>
<div>‚Ä¢ MAC table instability</div>
<div>‚Ä¢ Network congestion</div>
<div style="color: #4CAF50;">Solution: Enable Spanning Tree Protocol (STP)</div>`;
                } else {
                    return '<div style="color: #4CAF50;">‚úì No network loops detected</div>';
                }
            }
            
            simulateBroadcastStorm() {
                // Create multiple broadcast effects
                const switches = this.sim.devices.filter(d => d.userData.type === 'switch');
                
                if (switches.length === 0) {
                    return '<div style="color: #f44336;">No switches found. Add switches to simulate broadcast storm.</div>';
                }
                
                switches.forEach((sw, index) => {
                    setTimeout(() => {
                        this.sim.packetSimulator.createBroadcastEffect(sw, 'Broadcast Storm!', 0xff0000);
                    }, index * 500);
                });
                
                return `<div style="color: #ff9800;">‚ö†Ô∏è Simulating Broadcast Storm!</div>
<div>Multiple broadcasts are flooding the network.</div>
<div>Impact:</div>
<div>‚Ä¢ High CPU usage on all devices</div>
<div>‚Ä¢ Network performance degradation</div>
<div>‚Ä¢ Possible network failure</div>`;
            }
            
            simulateVLANTrunk() {
                const switches = this.sim.devices.filter(d => d.userData.type === 'switch');
                
                if (switches.length < 2) {
                    return '<div style="color: #f44336;">Need at least 2 switches for VLAN trunk simulation</div>';
                }
                
                // Find connection between switches
                const trunkLink = this.sim.connections.find(c => 
                    c.device1.userData.type === 'switch' && c.device2.userData.type === 'switch'
                );
                
                if (trunkLink) {
                    // Animate trunk link with multiple colors
                    const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00];
                    let colorIndex = 0;
                    
                    const animateTrunk = () => {
                        if (colorIndex < colors.length * 2) {
                            trunkLink.line.material.color = new THREE.Color(colors[colorIndex % colors.length]);
                            colorIndex++;
                            setTimeout(animateTrunk, 300);
                        } else {
                            trunkLink.line.material.color = new THREE.Color(0xffffff);
                        }
                    };
                    animateTrunk();
                    
                    return `<div style="color: #4CAF50;">VLAN Trunk Simulation</div>
<div>Trunk link configured between switches.</div>
<div>Multiple VLANs can traverse this link:</div>
<div>‚Ä¢ VLAN 10 (Red) - Sales</div>
<div>‚Ä¢ VLAN 20 (Green) - Engineering</div>
<div>‚Ä¢ VLAN 30 (Blue) - Management</div>
<div>‚Ä¢ VLAN 40 (Yellow) - Guest</div>`;
                }
                
                return '<div style="color: #f44336;">No switch-to-switch connections found</div>';
            }
            
            ping(args) {
                if (args.length === 0) {
                    return '<div style="color: #f44336;">Usage: ping [device_name or IP]</div>';
                }
                
                const target = args[0];
                const device = this.sim.devices.find(d => 
                    d.userData.name === target || d.userData.ip === target
                );
                
                if (!device) {
                    return `<div style="color: #f44336;">Destination host unreachable: ${target}</div>`;
                }
                
                const source = this.sim.devices[0]; // Use first device as source
                if (source && source !== device) {
                    this.sim.packetSimulator.animatePing(source, device);
                    return `<div>PING ${device.userData.ip} (${device.userData.name}):
<div>64 bytes from ${device.userData.ip}: icmp_seq=1 ttl=64 time=0.${Math.floor(Math.random() * 999)}ms</div>
<div>64 bytes from ${device.userData.ip}: icmp_seq=2 ttl=64 time=0.${Math.floor(Math.random() * 999)}ms</div>
<div>64 bytes from ${device.userData.ip}: icmp_seq=3 ttl=64 time=0.${Math.floor(Math.random() * 999)}ms</div>
<div>64 bytes from ${device.userData.ip}: icmp_seq=4 ttl=64 time=0.${Math.floor(Math.random() * 999)}ms</div>
<div style="color: #4CAF50;">--- ${device.userData.ip} ping statistics ---</div>
<div style="color: #4CAF50;">4 packets transmitted, 4 received, 0% packet loss</div></div>`;
                }
                
                return '<div style="color: #f44336;">No source device available</div>';
            }
            
            traceroute(args) {
                if (args.length === 0) {
                    return '<div style="color: #f44336;">Usage: traceroute [destination]</div>';
                }
                
                const dest = args[0];
                const device = this.sim.devices.find(d => 
                    d.userData.name === dest || d.userData.ip === dest
                );
                
                if (!device) {
                    return `<div style="color: #f44336;">Cannot resolve ${dest}: Unknown host</div>`;
                }
                
                // Simulate traceroute output
                let output = `<div>traceroute to ${device.userData.ip} (${device.userData.name}), 30 hops max</div>`;
                const hops = Math.min(3, this.sim.devices.length - 1);
                
                for (let i = 1; i <= hops; i++) {
                    const hopDevice = this.sim.devices[i] || device;
                    const time1 = (Math.random() * 50).toFixed(3);
                    const time2 = (Math.random() * 50).toFixed(3);
                    const time3 = (Math.random() * 50).toFixed(3);
                    output += `<div> ${i}  ${hopDevice.userData.ip} (${hopDevice.userData.name})  ${time1} ms  ${time2} ms  ${time3} ms</div>`;
                }
                
                this.sim.packetSimulator.simulateTraceroute();
                return output;
            }
            
            config(args) {
                if (args.length === 0) {
                    return '<div style="color: #f44336;">Usage: config [device_name]</div>';
                }
                
                const deviceName = args.join(' ');
                const device = this.sim.devices.find(d => d.userData.name === deviceName);
                
                if (!device) {
                    return `<div style="color: #f44336;">Device not found: ${deviceName}</div>`;
                }
                
                // Simulate entering config mode
                return `<div style="color: #4CAF50;">Entering configuration mode for ${device.userData.name}</div>
<div>Current configuration:</div>
<div>  hostname: ${device.userData.name}</div>
<div>  ip address: ${device.userData.ip} ${device.userData.subnet}</div>
<div>  status: ${device.userData.status}</div>
<div>  type: ${device.userData.type}</div>
<div style="color: #999;">Type 'exit' to leave config mode</div>`;
            }
            
            connect(args) {
                if (args.length < 2) {
                    return '<div style="color: #f44336;">Usage: connect [device1] [device2]</div>';
                }
                
                const device1 = this.sim.devices.find(d => d.userData.name === args[0]);
                const device2 = this.sim.devices.find(d => d.userData.name === args[1]);
                
                if (!device1 || !device2) {
                    return '<div style="color: #f44336;">One or both devices not found</div>';
                }
                
                if (device1 === device2) {
                    return '<div style="color: #f44336;">Cannot connect device to itself</div>';
                }
                
                this.sim.createConnection(device1, device2);
                return `<div style="color: #4CAF50;">Connected ${device1.userData.name} to ${device2.userData.name}</div>`;
            }
            
            disconnect(args) {
                if (args.length < 2) {
                    return '<div style="color: #f44336;">Usage: disconnect [device1] [device2]</div>';
                }
                
                const device1 = this.sim.devices.find(d => d.userData.name === args[0]);
                const device2 = this.sim.devices.find(d => d.userData.name === args[1]);
                
                if (!device1 || !device2) {
                    return '<div style="color: #f44336;">One or both devices not found</div>';
                }
                
                const connection = this.sim.connections.find(c => 
                    (c.device1 === device1 && c.device2 === device2) ||
                    (c.device1 === device2 && c.device2 === device1)
                );
                
                if (!connection) {
                    return '<div style="color: #f44336;">No connection exists between these devices</div>';
                }
                
                // Remove connection
                this.sim.scene.remove(connection.line);
                const index = this.sim.connections.indexOf(connection);
                this.sim.connections.splice(index, 1);
                
                return `<div style="color: #4CAF50;">Disconnected ${device1.userData.name} from ${device2.userData.name}</div>`;
            }
            
            show(args) {
                if (args.length === 0) {
                    return '<div style="color: #f44336;">Usage: show [devices|connections|routing]</div>';
                }
                
                switch(args[0]) {
                    case 'devices':
                        if (this.sim.devices.length === 0) {
                            return '<div>No devices in the network</div>';
                        }
                        let deviceList = '<div style="color: #4CAF50;">Network Devices:</div>';
                        this.sim.devices.forEach((d, i) => {
                            deviceList += `<div>${i + 1}. ${d.userData.name} (${d.userData.type})</div>`;
                            deviceList += `<div>   IP: ${d.userData.ip}/${d.userData.subnet}</div>`;
                            deviceList += `<div>   Status: ${d.userData.status}</div>`;
                        });
                        return deviceList;
                        
                    case 'connections':
                        if (this.sim.connections.length === 0) {
                            return '<div>No connections established</div>';
                        }
                        let connList = '<div style="color: #4CAF50;">Network Connections:</div>';
                        this.sim.connections.forEach((c, i) => {
                            connList += `<div>${i + 1}. ${c.device1.userData.name} <--> ${c.device2.userData.name}</div>`;
                        });
                        return connList;
                        
                    case 'routing':
                        return `<div style="color: #4CAF50;">Routing Table:</div>
<div>Destination     Gateway         Netmask         Interface</div>
<div>0.0.0.0         192.168.1.1     0.0.0.0         eth0</div>
<div>192.168.1.0     0.0.0.0         255.255.255.0   eth0</div>`;
                        
                    default:
                        return '<div style="color: #f44336;">Unknown show command</div>';
                }
            }
            
            clear() {
                document.getElementById('terminal-output').innerHTML = '';
                return '';
            }
            
            analyze() {
                const deviceCount = this.sim.devices.length;
                const connectionCount = this.sim.connections.length;
                const topology = this.detectTopology();
                
                return `<div style="color: #4CAF50;">Network Analysis:</div>
<div>Total Devices: ${deviceCount}</div>
<div>Total Connections: ${connectionCount}</div>
<div>Topology Type: ${topology}</div>
<div>Network Health: ${this.calculateHealth()}%</div>
<div>Redundancy: ${this.checkRedundancy()}</div>`;
            }
            
            detectTopology() {
                // Simple topology detection
                const avgConnections = this.sim.connections.length / this.sim.devices.length;
                if (avgConnections < 1.5) return 'Bus/Linear';
                if (avgConnections < 2.5) return 'Star';
                return 'Mesh/Hybrid';
            }
            
            calculateHealth() {
                // Simple health calculation
                return Math.floor(80 + Math.random() * 20);
            }
            
            checkRedundancy() {
                // Check for redundant paths
                return this.sim.connections.length > this.sim.devices.length - 1 ? 'Yes' : 'No';
            }
        }
        
        // Network Monitor Class
        class NetworkMonitor {
            constructor(simulator) {
                this.sim = simulator;
                this.monitoring = false;
                this.trafficData = [];
                this.packetLog = [];
                this.chart = null;
            }
            
            startMonitoring() {
                this.monitoring = true;
                this.updateTrafficChart();
                this.monitoringInterval = setInterval(() => {
                    if (this.monitoring) {
                        this.collectData();
                        this.updateTrafficChart();
                    }
                }, 1000);
            }
            
            stopMonitoring() {
                this.monitoring = false;
                if (this.monitoringInterval) {
                    clearInterval(this.monitoringInterval);
                }
            }
            
            collectData() {
                // Simulate traffic data
                const timestamp = new Date().toLocaleTimeString();
                const bandwidth = Math.floor(Math.random() * 100);
                
                this.trafficData.push({ time: timestamp, value: bandwidth });
                if (this.trafficData.length > 20) {
                    this.trafficData.shift();
                }
            }
            
            updateTrafficChart() {
                const canvas = document.getElementById('traffic-chart');
                const ctx = canvas.getContext('2d');
                
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw grid
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 1;
                
                for (let i = 0; i <= 10; i++) {
                    const y = (canvas.height / 10) * i;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
                
                // Draw data
                if (this.trafficData.length > 1) {
                    ctx.strokeStyle = '#4CAF50';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    this.trafficData.forEach((point, index) => {
                        const x = (canvas.width / (this.trafficData.length - 1)) * index;
                        const y = canvas.height - (point.value / 100) * canvas.height;
                        
                        if (index === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    });
                    
                    ctx.stroke();
                }
                
                // Draw labels
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.font = '12px Arial';
                ctx.fillText('100 Mbps', 5, 15);
                ctx.fillText('0 Mbps', 5, canvas.height - 5);
            }
            
            updateTab(tab) {
                switch(tab) {
                    case 'packets':
                        this.updatePacketList();
                        break;
                    case 'routing':
                        this.updateRoutingTable();
                        break;
                    case 'logs':
                        this.updateLogs();
                        break;
                }
            }
            
            updatePacketList() {
                const packetList = document.getElementById('packet-list');
                packetList.innerHTML = `
                    <div style="color: #4CAF50; margin-bottom: 10px;">Recent Packets:</div>
                    <div style="font-size: 12px; line-height: 1.6;">
                        <div>1. ICMP Echo Request: 192.168.1.100 ‚Üí 192.168.1.1</div>
                        <div>2. ICMP Echo Reply: 192.168.1.1 ‚Üí 192.168.1.100</div>
                        <div>3. ARP Request: Who has 192.168.1.1?</div>
                        <div>4. ARP Reply: 192.168.1.1 is at 00:1B:44:11:3A:B7</div>
                        <div>5. TCP SYN: 192.168.1.100:54321 ‚Üí 192.168.1.1:80</div>
                    </div>
                `;
            }
            
            updateRoutingTable() {
                const routingTable = document.getElementById('routing-table');
                routingTable.innerHTML = `
                    <div style="color: #4CAF50; margin-bottom: 10px;">Routing Table:</div>
                    <table style="width: 100%; font-size: 12px;">
                        <tr style="color: rgba(255,255,255,0.6);">
                            <th style="text-align: left;">Destination</th>
                            <th style="text-align: left;">Next Hop</th>
                            <th style="text-align: left;">Interface</th>
                            <th style="text-align: left;">Metric</th>
                        </tr>
                        <tr>
                            <td>0.0.0.0/0</td>
                            <td>192.168.1.1</td>
                            <td>eth0</td>
                            <td>1</td>
                        </tr>
                        <tr>
                            <td>192.168.1.0/24</td>
                            <td>Direct</td>
                            <td>eth0</td>
                            <td>0</td>
                        </tr>
                        <tr>
                            <td>10.0.0.0/8</td>
                            <td>192.168.1.254</td>
                            <td>eth0</td>
                            <td>2</td>
                        </tr>
                    </table>
                `;
            }
            
            updateLogs() {
                const logs = document.getElementById('log-entries');
                const timestamp = new Date().toLocaleTimeString();
                logs.innerHTML = `
                    <div style="color: #4CAF50; margin-bottom: 10px;">System Logs:</div>
                    <div style="font-size: 12px; line-height: 1.6; font-family: monospace;">
                        <div>[${timestamp}] Network interface eth0 up</div>
                        <div>[${timestamp}] DHCP: Obtained IP 192.168.1.100</div>
                        <div>[${timestamp}] Gateway reachable at 192.168.1.1</div>
                        <div>[${timestamp}] DNS configured: 8.8.8.8, 8.8.4.4</div>
                        <div>[${timestamp}] Network ready</div>
                    </div>
                `;
            }
        }
        
        // Packet Simulator Class
        class PacketSimulator {
            constructor(simulator) {
                this.sim = simulator;
                this.packetColors = {
                    ping: 0x00ff00, // Green
                    tcp: 0x2196F3,  // Blue
                    udp: 0xff9800,  // Orange
                    http: 0xe91e63,  // Pink
                    dns: 0x9c27b0,   // Purple
                    arp: 0xffeb3b    // Yellow
                };
            }
            
            // Main method for simulating packet transmission through the network
            simulateTransmission(source, destination, packetType, path) {
                if (!path || path.length < 2) {
                    this.sim.showNotification('Invalid network path', 'warning');
                    return;
                }
                
                // Get color based on packet type
                const packetColor = this.packetColors[packetType] || 0x00ff00;
                let packetLabel = packetType.toUpperCase();
                
                // Add protocol info to packet label based on type
                if (packetType === 'ping') {
                    packetLabel = 'ICMP ECHO';
                } else if (packetType === 'tcp') {
                    packetLabel = 'TCP SYN';
                } else if (packetType === 'udp') {
                    packetLabel = 'UDP';
                } else if (packetType === 'http') {
                    packetLabel = 'HTTP GET';
                }
                
                // Create packet with details
                const packet = this.createPacket(packetLabel, packetColor);
                packet.position.copy(source.position);
                this.sim.scene.add(packet);
                
                // Add packet header info
                packet.userData = {
                    sourceIP: source.userData.ip,
                    destIP: destination.userData.ip,
                    sourceMAC: source.userData.mac || this.generateRandomMAC(),
                    destMAC: destination.userData.mac || this.generateRandomMAC(),
                    ttl: 64,  // Time to live
                    protocol: packetType,
                    sourcePort: Math.floor(Math.random() * 16384) + 49152, // Ephemeral port
                    destPort: packetType === 'http' ? 80 : 0
                };
                
                // Save MAC addresses back to devices
                source.userData.mac = packet.userData.sourceMAC;
                destination.userData.mac = packet.userData.destMAC;
                
                // Show protocol explanation in info overlay
                this.showProtocolInfo(packetType, source.userData.name, destination.userData.name);
                
                // Display the network path in the terminal
                const terminal = document.getElementById('terminal');
                if (terminal.style.display !== 'none') {
                    const terminalOutput = document.getElementById('terminal-output');
                    
                    // Clear terminal if it's getting too full
                    if (terminalOutput.childElementCount > 50) {
                        terminalOutput.innerHTML = '';
                    }
                    
                    // Header for this transmission
                    terminalOutput.innerHTML += `<div style="color: white; font-weight: bold; margin-top: 10px;">====== NEW PACKET TRANSMISSION ======</div>`;
                    terminalOutput.innerHTML += `<div style="color: #4CAF50;">[Network] Sending ${packetType.toUpperCase()} packet from ${source.userData.name} to ${destination.userData.name}</div>`;
                    terminalOutput.innerHTML += `<div style="color: #9e9e9e;">[Packet] Source IP: ${packet.userData.sourceIP}, Dest IP: ${packet.userData.destIP}</div>`;
                    terminalOutput.innerHTML += `<div style="color: #9e9e9e;">[Packet] Source MAC: ${packet.userData.sourceMAC}, Dest MAC: ${packet.userData.destMAC}</div>`;
                    
                    // Show the complete path that will be taken
                    let pathStr = '<div style="color: #2196F3;">Route: ';
                    path.forEach((device, index) => {
                        pathStr += device.userData.name;
                        if (index < path.length - 1) {
                            pathStr += ' ‚Üí ';
                        }
                    });
                    pathStr += '</div>';
                    terminalOutput.innerHTML += pathStr;
                    
                    terminalOutput.scrollTop = terminalOutput.scrollHeight;
                }
                
                // Highlight the whole path before starting
                this.highlightPath(path);
                
                // Start the packet transmission with a slight delay
                setTimeout(() => {
                    // Animate the packet through each hop in the path
                    this.animatePacketThroughPath(packet, path, 0, () => {
                        // Transmission complete
                        this.sim.showNotification(`${packetType.toUpperCase()} transmission complete!`);
                        
                        // If this is a ping, simulate a response
                        if (packetType === 'ping') {
                            this.simulatePingResponse(path);
                        }
                    });
                }, 1000);
            }
            
            // Highlight the path to visually show the route
            highlightPath(path) {
                // Highlight connections along the path
                for (let i = 0; i < path.length - 1; i++) {
                    const currentDevice = path[i];
                    const nextDevice = path[i+1];
                    
                    // Find the connection line between these devices
                    const connection = this.sim.connections.find(conn => 
                        (conn.device1 === currentDevice && conn.device2 === nextDevice) ||
                        (conn.device1 === nextDevice && conn.device2 === currentDevice)
                    );
                    
                    if (connection && connection.line && connection.line.material) {
                        // Save original color
                        connection.originalColor = connection.line.material.color.clone();
                        connection.originalEmissive = connection.line.material.emissive.clone();
                        connection.originalIntensity = connection.line.material.emissiveIntensity;
                        
                        // Highlight the connection
                        connection.line.material.color = new THREE.Color(0xffffff);
                        connection.line.material.emissive = new THREE.Color(0xffffff);
                        connection.line.material.emissiveIntensity = 0.8;
                        
                        // Reset after a delay
                        setTimeout(() => {
                            if (connection.originalColor) {
                                connection.line.material.color = connection.originalColor;
                                connection.line.material.emissive = connection.originalEmissive;
                                connection.line.material.emissiveIntensity = connection.originalIntensity;
                            }
                        }, 5000);
                    }
                }
            }
            
            simulatePing() {
                // This is now handled by the destination dialog
                // The actual implementation is in simulateTransmission
                this.sim.showDestinationDialog();
            }
            
            // Show protocol information for the selected packet type
            showProtocolInfo(packetType, sourceName, destName) {
                const protocolInfo = {
                    ping: {
                        title: 'PING (ICMP Echo)',
                        description: 'Ping uses ICMP protocol to test connectivity between devices.',
                        details: `<strong>Process:</strong><br>
                        1. ${sourceName} sends ICMP Echo Request<br>
                        2. ${destName} receives and processes request<br>
                        3. ${destName} sends ICMP Echo Reply<br>
                        4. ${sourceName} receives reply and calculates RTT<br><br>
                        <strong>Used for:</strong> Network troubleshooting, latency testing`
                    },
                    tcp: {
                        title: 'TCP Packet Transmission',
                        description: 'TCP provides reliable, ordered, connection-oriented communication.',
                        details: `<strong>TCP Header Fields:</strong><br>
                        ‚Ä¢ Source Port: Random high port<br>
                        ‚Ä¢ Destination Port: Service port (e.g., 80 for HTTP)<br>
                        ‚Ä¢ Sequence Number: For ordering packets<br>
                        ‚Ä¢ Acknowledgment Number: Next expected byte<br>
                        ‚Ä¢ Window Size: Flow control<br><br>
                        <strong>Used for:</strong> Web browsing, email, file transfers`
                    },
                    udp: {
                        title: 'UDP Packet Transmission',
                        description: 'UDP provides fast, connectionless communication with no guarantees.',
                        details: `<strong>UDP Header Fields:</strong><br>
                        ‚Ä¢ Source Port: Random high port<br>
                        ‚Ä¢ Destination Port: Service port<br>
                        ‚Ä¢ Length: Size of packet<br>
                        ‚Ä¢ Checksum: Error detection<br><br>
                        <strong>Used for:</strong> DNS, streaming, VoIP, gaming`
                    },
                    http: {
                        title: 'HTTP Request',
                        description: 'HTTP is the foundation of data communication on the web.',
                        details: `<strong>HTTP Request:</strong><br>
                        ‚Ä¢ Method: GET, POST, PUT, DELETE<br>
                        ‚Ä¢ URL: Resource location<br>
                        ‚Ä¢ Headers: Metadata<br>
                        ‚Ä¢ Body: Request data (for POST/PUT)<br><br>
                        <strong>Used for:</strong> Web browsing, API calls, data transfer`
                    }
                };
                
                const info = protocolInfo[packetType] || protocolInfo.ping;
                this.sim.showInfoOverlay(info.title, info.description, info.details);
            }
            
            // Create a packet visualization with label
            createPacket(label, color) {
                const packetGeometry = new THREE.BoxGeometry(0.6, 0.4, 0.4);
                const packetMaterial = new THREE.MeshPhongMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.8,
                    transparent: true,
                    opacity: 0.9
                });
                const packet = new THREE.Mesh(packetGeometry, packetMaterial);
                
                // Add label
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                context.fillStyle = 'white';
                context.font = 'bold 20px Arial';
                context.textAlign = 'center';
                context.fillText(label, 128, 35);
                
                const labelTexture = new THREE.CanvasTexture(canvas);
                const labelMaterial = new THREE.SpriteMaterial({ map: labelTexture });
                const labelSprite = new THREE.Sprite(labelMaterial);
                labelSprite.scale.set(3, 0.75, 1);
                labelSprite.position.y = 1;
                packet.add(labelSprite);
                
                return packet;
            }
            
            // Animate a packet through a multi-hop path with proper forwarding behavior
            animatePacketThroughPath(packet, path, currentHop, onComplete) {
                if (currentHop >= path.length - 1) {
                    // We've reached the final destination
                    this.sim.scene.remove(packet);
                    this.flashDevice(path[currentHop], 0x00ff00);
                    
                    // Log to terminal that packet reached destination
                    const terminal = document.getElementById('terminal');
                    if (terminal.style.display !== 'none') {
                        const terminalOutput = document.getElementById('terminal-output');
                        terminalOutput.innerHTML += `<div style="color: #4CAF50;">[Network] Packet delivered to destination: ${path[currentHop].userData.name}</div>`;
                        terminalOutput.scrollTop = terminalOutput.scrollHeight;
                    }
                    
                    if (onComplete) onComplete();
                    return;
                }
                
                const source = path[currentHop];
                const target = path[currentHop + 1];
                const destination = path[path.length - 1]; // Final destination
                
                // Animate to the next hop
                this.animatePacketBetween(packet, source, target, () => {
                    // Flash the intermediary device when packet arrives
                    this.flashDevice(target, 0x00ff00);
                    
                    // Different forwarding behaviors based on device type
                    if (NetworkSimulator.DEVICE_TYPES.LAYER3_DEVICE.includes(target.userData.type)) {
                        // Router: IP-based forwarding
                        // Look up destination in routing table
                        const route = this.sim.lookupRouteForDestination(target, destination.userData.ip);
                        let processingMsg = 'Routing decision based on IP';
                        
                        if (route) {
                            // Terminal log message
                            const terminal = document.getElementById('terminal');
                            if (terminal.style.display !== 'none') {
                                const terminalOutput = document.getElementById('terminal-output');
                                let routeInfo = '';
                                
                                if (route.nextHop) {
                                    routeInfo = `Next hop: ${route.nextHop} via ${route.interface}`;
                                } else {
                                    routeInfo = `Direct delivery via ${route.interface}`;
                                }
                                
                                terminalOutput.innerHTML += `<div style="color: #2196F3;">[${target.userData.name}] IP lookup for ${destination.userData.ip} - ${routeInfo}</div>`;
                                terminalOutput.scrollTop = terminalOutput.scrollHeight;
                            }
                            
                            // Add route details to processing message
                            processingMsg += `\nNetwork: ${route.destination}/${this.sim.getNetmaskPrefixLength(route.netmask)}`;
                        }
                        
                        // Simulate IP routing decision processing
                        this.simulateDeviceProcessing(target, packet, processingMsg, 800, () => {
                            this.animatePacketThroughPath(packet, path, currentHop + 1, onComplete);
                        });
                    } 
                    else if (NetworkSimulator.DEVICE_TYPES.LAYER2_DEVICE.includes(target.userData.type)) {
                        // Switch: MAC-based forwarding
                        // Generate random MAC addresses if not already present
                        if (!source.userData.mac) {
                            source.userData.mac = this.generateRandomMAC();
                        }
                        if (!destination.userData.mac) {
                            destination.userData.mac = this.generateRandomMAC();
                        }
                        
                        // Terminal log message for switch forwarding
                        const terminal = document.getElementById('terminal');
                        if (terminal.style.display !== 'none') {
                            const terminalOutput = document.getElementById('terminal-output');
                            terminalOutput.innerHTML += `<div style="color: #FF9800;">[${target.userData.name}] MAC table lookup: ${source.userData.mac} ‚Üí ${source.userData.name}</div>`;
                            terminalOutput.innerHTML += `<div style="color: #FF9800;">[${target.userData.name}] Forwarding to ${path[currentHop+1].userData.name}</div>`;
                            terminalOutput.scrollTop = terminalOutput.scrollHeight;
                        }
                        
                        // Simulate MAC table lookup
                        this.simulateDeviceProcessing(target, packet, 'MAC address table lookup\nSwitching to correct port', 300, () => {
                            this.animatePacketThroughPath(packet, path, currentHop + 1, onComplete);
                        });
                    }
                    else if (NetworkSimulator.DEVICE_TYPES.WIRELESS.includes(target.userData.type)) {
                        // Wireless has some processing time
                        this.simulateDeviceProcessing(target, packet, 'Wireless forwarding', 300, () => {
                            this.animatePacketThroughPath(packet, path, currentHop + 1, onComplete);
                        });
                    }
                    else {
                        // Continue immediately for other device types (end devices)
                        this.animatePacketThroughPath(packet, path, currentHop + 1, onComplete);
                    }
                });
            }
            
            // Generate a random MAC address
            generateRandomMAC() {
                const hex = '0123456789ABCDEF';
                let mac = '';
                for (let i = 0; i < 6; i++) {
                    if (i > 0) mac += ':';
                    mac += hex[Math.floor(Math.random() * 16)];
                    mac += hex[Math.floor(Math.random() * 16)];
                }
                return mac;
            }
            
            // Simulate processing at a network device (router/switch)
            simulateDeviceProcessing(device, packet, processType, duration, callback) {
                // Create processing indicator
                const indicatorGeometry = new THREE.RingGeometry(0.8, 1, 32);
                const indicatorMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.6,
                    side: THREE.DoubleSide
                });
                
                const indicator = new THREE.Mesh(indicatorGeometry, indicatorMaterial);
                indicator.position.copy(device.position);
                indicator.position.y += 0.5;
                indicator.rotation.x = -Math.PI / 2;
                this.sim.scene.add(indicator);
                
                // Add processing label
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                context.fillStyle = 'white';
                context.font = '16px Arial';
                context.textAlign = 'center';
                context.fillText(processType, 128, 35);
                
                const labelTexture = new THREE.CanvasTexture(canvas);
                const labelMaterial = new THREE.SpriteMaterial({ map: labelTexture });
                const label = new THREE.Sprite(labelMaterial);
                label.scale.set(4, 1, 1);
                label.position.copy(device.position);
                label.position.y += 2;
                this.sim.scene.add(label);
                
                // Flash the indicator
                let phase = 0;
                const flashInterval = setInterval(() => {
                    indicator.material.opacity = 0.3 + Math.sin(phase) * 0.3;
                    phase += 0.5;
                }, 100);
                
                // Remove after processing
                setTimeout(() => {
                    clearInterval(flashInterval);
                    this.sim.scene.remove(indicator);
                    this.sim.scene.remove(label);
                    callback();
                }, duration);
            }
            
            // Simulate a ping response (path in reverse)
            simulatePingResponse(path) {
                // Create a response packet
                const packet = this.createPacket('ICMP REPLY', 0x4CAF50);
                
                // Reverse the path for the response
                const responsePath = [...path].reverse();
                
                // Start from the destination (now the source of the response)
                packet.position.copy(responsePath[0].position);
                this.sim.scene.add(packet);
                
                // Animate the response packet
                setTimeout(() => {
                    this.animatePacketThroughPath(packet, responsePath, 0, () => {
                        this.sim.showNotification('Ping response received!');
                    });
                }, 500);
            }
            
            simulateDHCP() {
                if (this.sim.devices.length < 2) {
                    this.sim.showNotification('Need at least a client and DHCP server', 'warning');
                    return;
                }
                
                this.sim.showInfoOverlay(
                    'DHCP Process',
                    'Dynamic Host Configuration Protocol automatically assigns IP addresses.',
                    `<strong>DORA Process:</strong><br>
                    1. <strong>Discover:</strong> Client broadcasts to find DHCP servers<br>
                    2. <strong>Offer:</strong> Server offers an IP address<br>
                    3. <strong>Request:</strong> Client requests the offered IP<br>
                    4. <strong>Acknowledge:</strong> Server confirms the assignment<br><br>
                    <strong>Benefits:</strong> Automatic IP configuration, centralized management`
                );
                
                // Simulate DHCP DORA process
                const client = this.sim.devices[0];
                const server = this.sim.devices.find(d => d.userData.type === 'server') || this.sim.devices[1];
                
                // Step 1: Discover (Broadcast)
                this.createBroadcastEffect(client, 'DHCP Discover', 0xffeb3b);
                
                setTimeout(() => {
                    // Step 2: Offer
                    this.animatePacketBetween(null, server, client, () => {}, 'DHCP Offer', 0x4CAF50);
                    
                    setTimeout(() => {
                        // Step 3: Request
                        this.animatePacketBetween(null, client, server, () => {}, 'DHCP Request', 0x2196F3);
                        
                        setTimeout(() => {
                            // Step 4: Acknowledge
                            this.animatePacketBetween(null, server, client, () => {
                                this.sim.showNotification('DHCP complete! IP assigned: 192.168.1.100');
                            }, 'DHCP ACK', 0x4CAF50);
                        }, 1500);
                    }, 1500);
                }, 1500);
            }
            
            simulateTCPHandshake() {
                if (this.sim.devices.length < 2) {
                    this.sim.showNotification('Need at least 2 devices for TCP handshake', 'warning');
                    return;
                }
                
                this.sim.showInfoOverlay(
                    'TCP 3-Way Handshake',
                    'TCP uses a three-way handshake to establish reliable connections.',
                    `<strong>Steps:</strong><br>
                    1. <strong>SYN:</strong> Client sends synchronize request<br>
                    2. <strong>SYN-ACK:</strong> Server acknowledges and synchronizes<br>
                    3. <strong>ACK:</strong> Client acknowledges server's response<br><br>
                    <strong>Purpose:</strong> Establishes sequence numbers, ensures both sides are ready`
                );
                
                const client = this.sim.devices[0];
                const server = this.sim.devices.find(d => d.userData.type === 'server') || this.sim.devices[1];
                
                // Step 1: SYN
                this.animatePacketBetween(null, client, server, () => {
                    this.flashDevice(server, 0xffeb3b);
                    
                    // Step 2: SYN-ACK
                    setTimeout(() => {
                        this.animatePacketBetween(null, server, client, () => {
                            this.flashDevice(client, 0x4CAF50);
                            
                            // Step 3: ACK
                            setTimeout(() => {
                                this.animatePacketBetween(null, client, server, () => {
                                    this.flashDevice(server, 0x4CAF50);
                                    this.sim.showNotification('TCP connection established!');
                                }, 'ACK', 0x4CAF50);
                            }, 1000);
                        }, 'SYN-ACK', 0x2196F3);
                    }, 1000);
                }, 'SYN', 0xffeb3b);
            }
            
            simulateTraceroute() {
                if (this.sim.devices.length < 3) {
                    this.sim.showNotification('Need at least 3 devices for traceroute', 'warning');
                    return;
                }
                
                this.sim.showInfoOverlay(
                    'Traceroute',
                    'Traceroute shows the path packets take through a network.',
                    `<strong>How it works:</strong><br>
                    ‚Ä¢ Sends packets with increasing TTL (Time to Live)<br>
                    ‚Ä¢ Each router decrements TTL by 1<br>
                    ‚Ä¢ When TTL reaches 0, router sends ICMP Time Exceeded<br>
                    ‚Ä¢ Maps each hop along the path<br><br>
                    <strong>Used for:</strong> Network diagnostics, finding routing issues`
                );
                
                const source = this.sim.devices[0];
                const hops = this.sim.devices.slice(1, 4); // Use up to 3 hops
                
                // Animate through each hop
                let hopIndex = 0;
                const traceHop = () => {
                    if (hopIndex < hops.length) {
                        const hop = hops[hopIndex];
                        this.animatePacketBetween(null, hopIndex === 0 ? source : hops[hopIndex - 1], hop, () => {
                            this.flashDevice(hop, 0xffeb3b);
                            this.sim.showNotification(`Hop ${hopIndex + 1}: ${hop.userData.name} (${hop.userData.ip})`);
                            hopIndex++;
                            setTimeout(traceHop, 1000);
                        }, `TTL=${hopIndex + 1}`, 0xffeb3b);
                    } else {
                        this.sim.showNotification('Traceroute complete!');
                    }
                };
                
                traceHop();
            }
            
            simulateARP() {
                if (this.sim.devices.length < 2) {
                    this.sim.showNotification('Need at least 2 devices for ARP', 'warning');
                    return;
                }
                
                this.sim.showInfoOverlay(
                    'ARP (Address Resolution Protocol)',
                    'ARP resolves IP addresses to MAC addresses on local networks.',
                    `<strong>Process:</strong><br>
                    1. <strong>ARP Request:</strong> "Who has IP 192.168.1.1?"<br>
                    2. <strong>Broadcast:</strong> Sent to all devices on network<br>
                    3. <strong>ARP Reply:</strong> "192.168.1.1 is at MAC 00:1B:44:11:3A:B7"<br>
                    4. <strong>Cache:</strong> Store mapping for future use<br><br>
                    <strong>Layer:</strong> Works between Layer 2 (Data Link) and Layer 3 (Network)`
                );
                
                const requester = this.sim.devices[0];
                const target = this.sim.devices[1];
                
                // Step 1: ARP Request (Broadcast)
                this.createBroadcastEffect(requester, `ARP: Who has ${target.userData.ip}?`, 0xff9800);
                
                setTimeout(() => {
                    // Step 2: ARP Reply (Unicast)
                    this.animatePacketBetween(null, target, requester, () => {
                        this.sim.showNotification(`ARP Reply: ${target.userData.ip} is at ${target.userData.mac || 'AA:BB:CC:DD:EE:FF'}`);
                        this.flashDevice(requester, 0x4CAF50);
                    }, 'ARP Reply', 0x4CAF50);
                }, 1500);
            }
            
            simulateDNS() {
                if (this.sim.devices.length < 2) {
                    this.sim.showNotification('Need at least a client and DNS server', 'warning');
                    return;
                }
                
                this.sim.showInfoOverlay(
                    'DNS (Domain Name System)',
                    'DNS translates domain names to IP addresses.',
                    `<strong>Process:</strong><br>
                    1. <strong>DNS Query:</strong> "What is the IP of example.com?"<br>
                    2. <strong>Recursive Lookup:</strong> DNS server checks cache/queries others<br>
                    3. <strong>DNS Response:</strong> "example.com is at 93.184.216.34"<br>
                    4. <strong>Cache:</strong> Result cached for future queries<br><br>
                    <strong>Hierarchy:</strong> Root servers ‚Üí TLD servers ‚Üí Authoritative servers`
                );
                
                const client = this.sim.devices[0];
                const dnsServer = this.sim.devices.find(d => d.userData.type === 'server') || this.sim.devices[1];
                
                // DNS Query
                this.animatePacketBetween(null, client, dnsServer, () => {
                    this.flashDevice(dnsServer, 0xffeb3b);
                    this.sim.showNotification('DNS Query: Resolving example.com...');
                    
                    // Simulate DNS server processing
                    setTimeout(() => {
                        // DNS Response
                        this.animatePacketBetween(null, dnsServer, client, () => {
                            this.sim.showNotification('DNS Response: example.com ‚Üí 93.184.216.34');
                            this.flashDevice(client, 0x4CAF50);
                        }, 'DNS Response', 0x4CAF50);
                    }, 1500);
                }, 'DNS Query', 0x2196F3);
            }
            
            // Animate a packet between two directly connected devices
            animatePacketBetween(packet, source, target, callback, label = '', color = 0x00ff00) {
                if (!packet) {
                    // Create new packet
                    const packetGeometry = new THREE.BoxGeometry(0.6, 0.4, 0.4);
                    const packetMaterial = new THREE.MeshPhongMaterial({
                        color: color,
                        emissive: color,
                        emissiveIntensity: 0.6
                    });
                    packet = new THREE.Mesh(packetGeometry, packetMaterial);
                    
                    if (label) {
                        const canvas = document.createElement('canvas');
                        const context = canvas.getContext('2d');
                        canvas.width = 256;
                        canvas.height = 64;
                        context.fillStyle = 'white';
                        context.font = 'bold 24px Arial';
                        context.textAlign = 'center';
                        context.fillText(label, 128, 40);
                        
                        const labelTexture = new THREE.CanvasTexture(canvas);
                        const labelMaterial = new THREE.SpriteMaterial({ map: labelTexture });
                        const labelSprite = new THREE.Sprite(labelMaterial);
                        labelSprite.scale.set(3, 0.75, 1);
                        labelSprite.position.y = 1;
                        packet.add(labelSprite);
                    }
                    
                    this.sim.scene.add(packet);
                }
                
                packet.position.copy(source.position);
                
                // Create path
                const points = [];
                const segments = 50;
                
                for (let i = 0; i <= segments; i++) {
                    const t = i / segments;
                    const point = new THREE.Vector3().lerpVectors(
                        source.position,
                        target.position,
                        t
                    );
                    
                    // Add curve
                    const distance = source.position.distanceTo(target.position);
                    const height = Math.min(distance * 0.3, 5);
                    point.y += Math.sin(t * Math.PI) * height;
                    
                    points.push(point);
                }
                
                const curve = new THREE.CatmullRomCurve3(points);
                const duration = 2000;
                const startTime = Date.now();
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    const position = curve.getPoint(progress);
                    packet.position.copy(position);
                    
                    // Rotate packet
                    packet.rotation.y += 0.1;
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        if (label) {
                            this.sim.scene.remove(packet);
                        }
                        callback();
                    }
                };
                
                animate();
            }
            
            createBroadcastEffect(device, label, color) {
                // Create expanding ring effect for broadcast
                const ringGeometry = new THREE.RingGeometry(0.1, 1, 32);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.8,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.position.copy(device.position);
                ring.position.y += 0.1;
                ring.rotation.x = -Math.PI / 2;
                
                this.sim.scene.add(ring);
                
                // Animate expansion
                const duration = 2000;
                const startTime = Date.now();
                const maxRadius = 15;
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    const scale = 1 + progress * maxRadius;
                    ring.scale.set(scale, scale, 1);
                    ring.material.opacity = 0.8 * (1 - progress);
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        this.sim.scene.remove(ring);
                    }
                };
                
                animate();
                
                this.sim.showNotification(`Broadcasting: ${label}`);
            }
            
            flashDevice(device, color) {
                device.traverse((child) => {
                    if (child.material && child.material.emissive) {
                        const originalEmissive = child.material.emissive.clone();
                        child.material.emissive = new THREE.Color(color);
                        child.material.emissiveIntensity = 0.8;
                        
                        setTimeout(() => {
                            child.material.emissive = originalEmissive;
                            child.material.emissiveIntensity = 0.3;
                        }, 500);
                    }
                });
            }
        }
        
        // Tutorial System Class
        class TutorialSystem {
            constructor(simulator) {
                this.sim = simulator;
                this.currentStep = 0;
                this.tutorials = {
                    'basic-network': {
                        title: 'Basic Network Setup',
                        steps: [
                            {
                                instruction: 'Welcome! Let\'s build a simple network. First, drag a Desktop PC from the palette to the grid.',
                                validate: () => this.sim.devices.some(d => d.userData.type === 'desktop'),
                                highlight: 'desktop'
                            },
                            {
                                instruction: 'Great! Now add a Router to connect networks.',
                                validate: () => this.sim.devices.some(d => d.userData.type === 'router'),
                                highlight: 'router'
                            },
                            {
                                instruction: 'Perfect! Now switch to Connect Mode (press 2) and connect the PC to the Router.',
                                validate: () => this.sim.connections.length > 0,
                                highlight: 'connect-mode'
                            },
                            {
                                instruction: 'Excellent! You\'ve created a basic network. Click on devices to configure their IP addresses.',
                                validate: () => true,
                                complete: true
                            }
                        ]
                    },
                    'tcp-ip': {
                        title: 'Understanding TCP/IP',
                        steps: [
                            {
                                instruction: 'TCP/IP is the foundation of internet communication. Set up two PCs and a router.',
                                validate: () => this.sim.devices.length >= 3
                            },
                            {
                                instruction: 'Connect both PCs to the router. This creates a local network.',
                                validate: () => this.sim.connections.length >= 2
                            },
                            {
                                instruction: 'Now let\'s see TCP in action. Run a TCP Handshake simulation from the menu.',
                                validate: () => true,
                                action: () => this.sim.showSimulationMenu()
                            }
                        ]
                    },
                    'routing': {
                        title: 'Routing Basics',
                        steps: [
                            {
                                instruction: 'Routing directs packets between networks. Create a network with at least 2 routers.',
                                validate: () => this.sim.devices.filter(d => d.userData.type === 'router').length >= 2
                            },
                            {
                                instruction: 'Connect the routers together. This creates the backbone of your network.',
                                validate: () => {
                                    const routers = this.sim.devices.filter(d => d.userData.type === 'router');
                                    return this.sim.connections.some(c => 
                                        routers.includes(c.device1) && routers.includes(c.device2)
                                    );
                                }
                            },
                            {
                                instruction: 'Add PCs to different routers. They\'re now on different networks.',
                                validate: () => this.sim.devices.filter(d => d.userData.type === 'desktop').length >= 2
                            },
                            {
                                instruction: 'Configure different subnets for each router (e.g., 192.168.1.x and 192.168.2.x)',
                                validate: () => true,
                                complete: true
                            }
                        ]
                    },
                    'vlan': {
                        title: 'VLAN Configuration',
                        steps: [
                            {
                                instruction: 'VLANs create logical network segments. Start by adding a switch.',
                                validate: () => this.sim.devices.some(d => d.userData.type === 'switch')
                            },
                            {
                                instruction: 'Add at least 3 PCs and connect them to the switch.',
                                validate: () => {
                                    const pcs = this.sim.devices.filter(d => d.userData.type === 'desktop' || d.userData.type === 'laptop');
                                    const switches = this.sim.devices.filter(d => d.userData.type === 'switch');
                                    return pcs.length >= 3 && switches.length > 0;
                                }
                            },
                            {
                                instruction: 'Press Ctrl+V to open VLAN configuration. Assign PCs to different VLANs.',
                                validate: () => true,
                                action: () => this.sim.openVLANConfig()
                            },
                            {
                                instruction: 'VLANs isolate traffic between groups. Devices in different VLANs cannot communicate without a router.',
                                validate: () => true,
                                complete: true
                            }
                        ]
                    },
                    'security': {
                        title: 'Network Security',
                        steps: [
                            {
                                instruction: 'Security is crucial in networking. Start by adding a Firewall device.',
                                validate: () => this.sim.devices.some(d => d.userData.type === 'firewall')
                            },
                            {
                                instruction: 'Place the firewall between your internal network and the cloud/internet.',
                                validate: () => this.sim.devices.some(d => d.userData.type === 'cloud')
                            },
                            {
                                instruction: 'Connect your internal devices to the firewall, and the firewall to the cloud.',
                                validate: () => {
                                    const firewall = this.sim.devices.find(d => d.userData.type === 'firewall');
                                    return firewall && this.sim.connections.filter(c => 
                                        c.device1 === firewall || c.device2 === firewall
                                    ).length >= 2;
                                }
                            },
                            {
                                instruction: 'The firewall now inspects all traffic between your network and the internet. Configure rules to allow/block specific traffic.',
                                validate: () => true,
                                complete: true
                            }
                        ]
                    },
                    'troubleshoot': {
                        title: 'Network Troubleshooting',
                        steps: [
                            {
                                instruction: 'Let\'s practice troubleshooting. Build a network with at least 4 devices.',
                                validate: () => this.sim.devices.length >= 4
                            },
                            {
                                instruction: 'Open the terminal (Ctrl+T) and use the "ping" command to test connectivity.',
                                validate: () => true,
                                action: () => this.sim.toggleTerminal()
                            },
                            {
                                instruction: 'Try "traceroute" to see the path packets take through your network.',
                                validate: () => true
                            },
                            {
                                instruction: 'Use "analyze network" to check for issues like loops or single points of failure.',
                                validate: () => true
                            },
                            {
                                instruction: 'Great job! You now know basic troubleshooting. Remember: ping tests connectivity, traceroute shows path, and analyze checks topology.',
                                validate: () => true,
                                complete: true
                            }
                        ]
                    }
                };
            }
            
            startTutorial(type) {
                const tutorial = this.tutorials[type];
                if (!tutorial) return;
                
                this.currentTutorial = tutorial;
                this.currentStep = 0;
                
                this.showTutorialStep();
            }
            
            showTutorialStep() {
                if (!this.currentTutorial || this.currentStep >= this.currentTutorial.steps.length) {
                    this.completeTutorial();
                    return;
                }
                
                const step = this.currentTutorial.steps[this.currentStep];
                
                // Show instruction overlay
                const overlay = document.createElement('div');
                overlay.id = 'tutorial-overlay';
                overlay.style.cssText = `
                    position: fixed;
                    bottom: 100px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(0, 0, 0, 0.9);
                    color: white;
                    padding: 20px 30px;
                    border-radius: 10px;
                    font-size: 16px;
                    z-index: 1000;
                    max-width: 600px;
                    text-align: center;
                    border: 2px solid #4CAF50;
                `;
                
                overlay.innerHTML = `
                    <div style="margin-bottom: 15px;">${step.instruction}</div>
                    <button onclick="networkSim.tutorialSystem.checkStep()" 
                            style="background: #4CAF50; color: white; border: none; 
                                   padding: 10px 20px; border-radius: 5px; cursor: pointer;">
                        ${step.complete ? 'Complete Tutorial' : 'Next'}
                    </button>
                    <button onclick="networkSim.tutorialSystem.skipTutorial()" 
                            style="background: transparent; color: #999; border: 1px solid #999; 
                                   padding: 10px 20px; border-radius: 5px; cursor: pointer; margin-left: 10px;">
                        Skip
                    </button>
                `;
                
                // Remove existing overlay
                const existing = document.getElementById('tutorial-overlay');
                if (existing) existing.remove();
                
                document.body.appendChild(overlay);
                
                // Highlight relevant elements
                if (step.highlight) {
                    this.highlightElement(step.highlight);
                }
                
                // Execute action if any
                if (step.action) {
                    step.action();
                }
            }
            
            checkStep() {
                const step = this.currentTutorial.steps[this.currentStep];
                
                if (!step.validate || step.validate()) {
                    this.currentStep++;
                    this.showTutorialStep();
                } else {
                    this.sim.showNotification('Complete the current step before proceeding', 'warning');
                }
            }
            
            skipTutorial() {
                const overlay = document.getElementById('tutorial-overlay');
                if (overlay) overlay.remove();
                this.currentTutorial = null;
            }
            
            completeTutorial() {
                const overlay = document.getElementById('tutorial-overlay');
                if (overlay) overlay.remove();
                
                this.sim.showInfoOverlay(
                    'Tutorial Complete! üéâ',
                    'Great job! You\'ve completed the tutorial. Continue exploring or try another tutorial.',
                    '<strong>Next steps:</strong><br>‚Ä¢ Experiment with different network topologies<br>‚Ä¢ Try other protocol simulations<br>‚Ä¢ Configure device properties<br>‚Ä¢ Use the terminal for advanced commands'
                );
            }
            
            highlightElement(element) {
                // Add visual highlighting to guide users
                // This would highlight specific UI elements or device types
            }
        }
        
        // Initialize simulator
        const networkSim = new NetworkSimulator();
    </script>
    
    <!-- Destination PC Selection Dialog -->
    <div id="destination-dialog" class="modal" style="display: none; z-index: 1000;">
        <div class="modal-header">
            <span>Select Packet Destination</span>
            <button class="close-btn" onclick="networkSim.closeDestinationDialog()">√ó</button>
        </div>
        <div class="modal-content">
            <div class="form-group">
                <label>Source PC:</label>
                <select id="packet-source" class="form-control">
                    <!-- Will be populated dynamically with only PCs -->
                </select>
            </div>
            <div class="form-group">
                <label><strong>Which PC do you want to send the packet to?</strong></label>
                <select id="packet-destination" class="form-control">
                    <!-- Will be populated dynamically with only PCs -->
                </select>
            </div>
            <div class="form-group">
                <label>Packet Type:</label>
                <select id="packet-type" class="form-control">
                    <option value="ping">ICMP Echo (Ping)</option>
                    <option value="tcp">TCP Packet</option>
                    <option value="udp">UDP Packet</option>
                    <option value="http">HTTP Request</option>
                </select>
            </div>
            <div class="btn-group">
                <button class="btn btn-save" onclick="networkSim.startPacketTransmission()">Start Transmission</button>
                <button class="btn btn-cancel" onclick="networkSim.closeDestinationDialog()">Cancel</button>
            </div>
        </div>
    </div>
</body>
</html>